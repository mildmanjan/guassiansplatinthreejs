<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Portal to Gaussian Splat Scene</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            overflow: hidden;
            background: #000;
        }
        #canvas-container {
            width: 100vw;
            height: 100vh;
        }
        #instructions {
            position: fixed;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            font-size: 14px;
            max-width: 300px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(74, 158, 255, 0.3);
            z-index: 100;
        }
        #instructions h2 {
            margin: 0 0 15px 0;
            font-size: 18px;
            color: #4a9eff;
        }
        #instructions ul {
            list-style: none;
            padding: 0;
        }
        #instructions li {
            margin: 8px 0;
            padding-left: 20px;
            position: relative;
        }
        #instructions li:before {
            content: "‚Üí";
            position: absolute;
            left: 0;
            color: #4a9eff;
        }
        #loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 20px;
            text-align: center;
            background: rgba(0, 0, 0, 0.8);
            padding: 30px;
            border-radius: 10px;
            min-width: 300px;
            z-index: 1000;
        }
        .spinner {
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-top: 3px solid #4a9eff;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        #portal-prompt {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    color: white;
    background: rgba(74, 158, 255, 0.9);
    padding: 20px 40px;
    border-radius: 10px;
    font-size: 18px;
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.3s;
    z-index: 200;
}

#portal-prompt.show {
    opacity: 1;
}
        #file-info {
            position: fixed;
            bottom: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 8px;
            font-size: 12px;
            font-family: monospace;
            z-index: 100;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    
    <div id="loading">
        <div class="spinner"></div>
        <div id="loading-text">Loading Scene...</div>
        <div style="font-size: 14px; margin-top: 10px; color: #aaa;">
            Place your .ply file in the same folder
        </div>
    </div>
    
    <div id="instructions" style="display: none;">
        <h2>üåÄ Portal Controls</h2>
        <ul>
            <li>Left click + drag to orbit</li>
            <li>Scroll to zoom in/out</li>
            <li>Navigate closer to portal</li>
            <li>See Gaussian splat through portal!</li>
        </ul>
    </div>
    
    <div id="file-info" style="display: none;">
        <div>üìÅ <span id="file-name">Loading...</span></div>
        <div>üìä <span id="splat-info">Initializing...</span></div>
        <div>üé® Gaussian Splatting Active</div>
    </div>
<div id="portal-prompt">
    Click portal to enter the 3D scene!
</div>
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import * as GaussianSplats3D from 'https://cdn.jsdelivr.net/npm/@mkkellogg/gaussian-splats-3d@latest/build/gaussian-splats-3d.module.min.js';

        // ====== CONFIGURATION ======
        // UPDATE THIS PATH to match your .ply file location
        //const SPLAT_FILE = 'InteriorDesign.ply';
        const SPLAT_FILE = 'https://huggingface.co/mysterytreebeast/gaussian-splat-models/resolve/main/InteriorDesign.ply';

        const USE_PLACEHOLDER = false;

        // ====== MAIN SCENE SETUP ======
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0a0a);

        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 1.6, 5);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        // ‚ú® ENABLE SHADOWS ‚ú®
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;  // Soft shadows


        document.getElementById('canvas-container').appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 2;
        controls.maxDistance = 15;
        controls.maxPolarAngle = Math.PI / 2;
        controls.target.set(0, 1.6, -3);

        // ====== LIGHTING ======
     // ====== DRAMATIC LIGHTING ======
// Very dark ambient light so spotlights stand out
scene.add(new THREE.AmbientLight(0x111111, 0.2));  // Much darker!

// Remove or reduce directional light
// const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
// dirLight.position.set(5, 5, 5);
// scene.add(dirLight);

// Remove point light (spotlights will provide all light)
// const pointLight = new THREE.PointLight(0x4a9eff, 0.5);
// pointLight.position.set(-3, 2, 0);
// scene.add(pointLight);

// Main spotlight on portal (bright blue beam)
const spotlight1 = new THREE.SpotLight(0x4a9eff, 10);  // Increased intensity from 2 to 10
spotlight1.position.set(0, 8, 2);                      // Higher up
spotlight1.angle = Math.PI / 5;                        // Wider cone
spotlight1.penumbra = 0.6;                             // Softer edges
spotlight1.decay = 1.5;                                // Less falloff
spotlight1.distance = 20;                              // Longer reach
spotlight1.castShadow = true;
spotlight1.target.position.set(0, 1.5, -3);
scene.add(spotlight1);
scene.add(spotlight1.target);

// Shadow settings for spotlight1
spotlight1.shadow.mapSize.width = 2048;
spotlight1.shadow.mapSize.height = 2048;
spotlight1.shadow.camera.near = 1;
spotlight1.shadow.camera.far = 20;

// Accent spotlight on cube (dramatic red)
const spotlight2 = new THREE.SpotLight(0xff3333, 5);   // Brighter red
spotlight2.position.set(-4, 6, 3);                     // Higher
spotlight2.angle = Math.PI / 7;
spotlight2.penumbra = 0.5;
spotlight2.decay = 1.5;
spotlight2.distance = 12;
spotlight2.castShadow = true;
spotlight2.target.position.set(-2, 0.5, 1);
scene.add(spotlight2);
scene.add(spotlight2.target);

// Rim light from behind (cool white/blue)
const spotlight3 = new THREE.SpotLight(0xaaccff, 3);   // Cool white
spotlight3.position.set(0, 5, -8);
spotlight3.angle = Math.PI / 3;
spotlight3.penumbra = 0.7;
spotlight3.decay = 1.5;
spotlight3.distance = 15;
spotlight3.target.position.set(0, 1, -3);
scene.add(spotlight3);
scene.add(spotlight3.target);

// Add visible helpers to see the spotlights (remove these later if you want)
const helper1 = new THREE.SpotLightHelper(spotlight1, 0x4a9eff);
const helper2 = new THREE.SpotLightHelper(spotlight2, 0xFF0000);
const helper3 = new THREE.SpotLightHelper(spotlight3, 0xaaccff);
//scene.add(helper1);
//scene.add(helper2);
//scene.add(helper3);

console.log('‚ú® Spotlights added - check scene!');

  // ====== ROOM GEOMETRY ======
const floor = new THREE.Mesh(
    new THREE.PlaneGeometry(20, 20),
    new THREE.MeshStandardMaterial({ color: 0x1fffff })  // Darker floor
);
floor.rotation.x = -Math.PI / 2;
floor.position.y = -1;
floor.receiveShadow = true;  // ‚úÖ Receive shadows
scene.add(floor);

const wallMat = new THREE.MeshStandardMaterial({ 
    color: 0xffffff,  // Darker wall
    side: THREE.DoubleSide 
});
const backWall = new THREE.Mesh(new THREE.PlaneGeometry(20, 8), wallMat);
backWall.position.set(0, 3, -5);
backWall.receiveShadow = true;  // ‚úÖ Receive shadows
scene.add(backWall);

const cube = new THREE.Mesh(
    new THREE.BoxGeometry(0.8, 0.8, 0.8),
    new THREE.MeshStandardMaterial({ color: 0xFFFF00 })
);
cube.position.set(-2, 0.5, 1);
cube.castShadow = true;     // ‚úÖ Cast shadows
cube.receiveShadow = true;  // ‚úÖ Receive shadows
scene.add(cube);

        // ====== PORTAL SCENE (separate scene for splat) ======
        const portalScene = new THREE.Scene();
        portalScene.background = new THREE.Color(0x1a1a2a);
        
        const portalCamera = new THREE.PerspectiveCamera(60, 1, 0.1, 100);
        portalCamera.position.set(0, 1, 3);
        portalCamera.lookAt(0, 0, 0);
        
        // Add lighting to portal scene
        portalScene.add(new THREE.AmbientLight(0xffffff, 0.8));
        const portalDirLight = new THREE.DirectionalLight(0xffffff, 0.5);
        portalDirLight.position.set(5, 5, 5);
        portalScene.add(portalDirLight);
        
        // Render target for portal - increased resolution for better quality
        const portalRenderTarget = new THREE.WebGLRenderTarget(2048, 2048, {
            minFilter: THREE.LinearFilter,
            magFilter: THREE.LinearFilter,
            format: THREE.RGBAFormat
        });

        // ====== GAUSSIAN SPLAT VIEWER ======
        let splatViewer = null;

        /**
         * Load Gaussian Splat with proper configuration
         * ‚úÖ FIXED: Using correct settings from working project
         */
   /**
 * Load Gaussian Splat with proper configuration
 * ‚úÖ FIXED: Removed splatViewer.start() call - not needed in manual mode
 */
async function loadGaussianSplat() {
    if (USE_PLACEHOLDER) {
        console.log('üìã Using placeholder mode');
        const placeholder = createPlaceholderMesh();
        portalScene.add(placeholder);
        document.getElementById('file-name').textContent = 'Placeholder Mode';
        document.getElementById('splat-info').textContent = 'Set USE_PLACEHOLDER=false';
        return;
    }

    try {
        console.log(`üìÑ Loading: ${SPLAT_FILE}`);
        document.getElementById('loading-text').textContent = `Loading ${SPLAT_FILE}...`;

        // ‚úÖ CRITICAL FIX: Proper viewer configuration
        splatViewer = new GaussianSplats3D.Viewer({
            threeScene: portalScene,           // Use portal scene
            renderer: renderer,                 // Share main renderer
            camera: portalCamera,              // Use portal camera
            selfDrivenMode: false,             // ‚úÖ Manual control - we handle rendering
            useBuiltInControls: false,         // No built-in controls
            showLoadingSpinner: false,         // Hide built-in spinner
            
            // ‚úÖ CRITICAL: These settings prevent SharedArrayBuffer errors
            gpuAcceleratedSort: false,         // Disable GPU acceleration
            integerBasedSort: false,           // Disable integer sorting  
            sharedMemoryForWorkers: false,     // CRITICAL: Prevents SharedArrayBuffer error
            
            enableSplatSorting: true,          // Enable splat sorting
            halfPrecisionCovariancesOnGPU: true,
            dynamicScene: false,
            webXRMode: GaussianSplats3D.WebXRMode.None,
            renderMode: GaussianSplats3D.RenderMode.Always,
            logLevel: GaussianSplats3D.LogLevel.Info  // See loading progress
        });

        console.log('‚úÖ Viewer created with proper settings');
        
        // Initialize the viewer
        await splatViewer.init();
        console.log('‚úÖ Viewer initialized');

        // ‚úÖ FIXED: Load splat scene with proper options
        await splatViewer.addSplatScene(SPLAT_FILE, {
            progressiveLoad: true,             // Load progressively for better UX
            splatAlphaRemovalThreshold: 5,     // Remove transparent splats
            position: [0, 0, 0],               // Center position
            rotation: [1, 0, 0, 0],            // Identity rotation (quaternion)
            scale: [5, 5, 5]                   // Scale up 5x
        });

        console.log('‚úÖ Splat scene loaded successfully!');

        // ‚úÖ REMOVED: splatViewer.start() - not needed in selfDrivenMode: false
        // We handle rendering manually in the animate loop

        document.getElementById('file-name').textContent = SPLAT_FILE;
        document.getElementById('splat-info').textContent = 'Rendering active ‚úì';

    } catch (error) {
        console.error('‚ùå Error loading splat:', error);
        console.error('Stack:', error.stack);
        
        // Show fallback placeholder
        const placeholder = createPlaceholderMesh();
        portalScene.add(placeholder);
        
        document.getElementById('file-name').textContent = 'Load failed - check console';
        document.getElementById('splat-info').textContent = error.message.substring(0, 40);
    }
}

        /**
         * Create placeholder mesh for testing
         */
        function createPlaceholderMesh() {
            const geometry = new THREE.PlaneGeometry(3, 3);
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            // Create gradient background
            const gradient = ctx.createRadialGradient(256, 256, 0, 256, 256, 256);
            gradient.addColorStop(0, '#4a9eff');
            gradient.addColorStop(0.5, '#2a5eff');
            gradient.addColorStop(1, '#1a3a8a');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 512, 512);
            
            // Add "splats" effect
            for (let i = 0; i < 50; i++) {
                const x = Math.random() * 512;
                const y = Math.random() * 512;
                const radius = Math.random() * 30 + 10;
                const alpha = Math.random() * 0.5 + 0.3;
                
                const splatGrad = ctx.createRadialGradient(x, y, 0, x, y, radius);
                splatGrad.addColorStop(0, `rgba(255, 255, 255, ${alpha})`);
                splatGrad.addColorStop(1, 'rgba(255, 255, 255, 0)');
                
                ctx.fillStyle = splatGrad;
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fill();
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide });
            return new THREE.Mesh(geometry, material);
        }

        // ====== PORTAL GEOMETRY ======
        const portalGroup = new THREE.Group();
        portalGroup.position.set(0, 1.5, -3);

        // Portal frame
        const frame = new THREE.Mesh(
            new THREE.BoxGeometry(2.2, 3.2, 0.1),
            new THREE.MeshStandardMaterial({ 
                color: 0x1a1a1a,
                metalness: 0.8,
                roughness: 0.2 
            })
        );
        portalGroup.add(frame);

        // Portal surface showing the render texture
        const portalSurface = new THREE.Mesh(
            new THREE.PlaneGeometry(2, 3),
            new THREE.MeshBasicMaterial({ 
                map: portalRenderTarget.texture,
                side: THREE.DoubleSide
            })
        );
        portalSurface.position.z = 0.06;
        portalGroup.add(portalSurface);

        // Portal glow effect
        const glow = new THREE.Mesh(
            new THREE.PlaneGeometry(2.1, 3.1),
            new THREE.MeshBasicMaterial({ 
                color: 0x4a9eff,
                transparent: true,
                opacity: 0.2,
                side: THREE.DoubleSide
            })
        );
        glow.position.z = 0.05;
        portalGroup.add(glow);

        scene.add(portalGroup);

        // ====== INITIALIZATION ======
        async function init() {
            await loadGaussianSplat();
            
            document.getElementById('loading').style.display = 'none';
            document.getElementById('instructions').style.display = 'block';
            document.getElementById('file-info').style.display = 'block';
            
            animate();
            console.log('üåÄ Portal ready!');
        }

        // ====== ANIMATION LOOP ======
// ====== ENHANCED NAVIGATION WITH PORTAL ENTRY ======
let portalCameraAngle = 0;
let isInSplatScene = false;  // Track if user is inside splat
let splatControls = null;    // Controls for inside splat scene

// Create separate controls for splat scene navigation
function createSplatControls() {
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.minDistance = 0.5;      // Get very close
    controls.maxDistance = 50;       // Explore far
    controls.enabled = false;         // Start disabled
    return controls;
}

splatControls = createSplatControls();

// Raycaster for portal clicking
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();

// Handle portal click to enter/exit
renderer.domElement.addEventListener('click', (event) => {
    // Calculate mouse position
    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
    
    if (!isInSplatScene) {
        // Check if clicking on portal
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(portalGroup.children, true);
        
        if (intersects.length > 0) {
            enterSplatScene();
        }
    }
});

// Show prompt when near portal
function updatePortalProximity() {
    if (isInSplatScene) return;
    
    const distanceToPortal = camera.position.distanceTo(portalGroup.position);
    const prompt = document.getElementById('portal-prompt');
    
    if (distanceToPortal < 5) {
        prompt.classList.add('show');
    } else {
        prompt.classList.remove('show');
    }
}

// Enter the splat scene
function enterSplatScene() {
    console.log('üö™ Entering splat scene...');
    isInSplatScene = true;
    
    // Disable main controls
    controls.enabled = false;
    
    // Enable splat controls
    splatControls.enabled = true;
    
    // ‚úÖ CRITICAL FIX: Switch the splat viewer to use the main camera
    if (splatViewer) {
        // Update the viewer's camera reference
        splatViewer.camera = camera;
        
        // Remove splat from portal scene
        if (splatViewer.splatMesh) {
            portalScene.remove(splatViewer.splatMesh);
        }
        
        // Add splat to main scene
        if (splatViewer.splatMesh) {
            scene.add(splatViewer.splatMesh);
        }
    }
    
    // Position camera inside the splat scene
    camera.position.set(0, 2, 8);
    camera.lookAt(0, 0, 0);
    splatControls.target.set(0, 0, 0);
    splatControls.update();
    
    // Change background for immersion
    scene.background = new THREE.Color(0x1a1a2a);
    
    // Hide main scene objects
    floor.visible = false;
    backWall.visible = false;
    cube.visible = false;
    portalGroup.visible = false;
    
    // Update instructions
    document.getElementById('instructions').innerHTML = `
        <h2>üåÄ Inside Splat Scene</h2>
        <ul>
            <li>Drag to rotate view</li>
            <li>Scroll to zoom in/out</li>
            <li>Explore the 3D space!</li>
            <li>Press ESC to exit</li>
        </ul>
    `;
    
    document.getElementById('portal-prompt').classList.remove('show');
    
    console.log('‚úÖ Camera switched to main camera for splat navigation');
}

// Exit the splat scene
function exitSplatScene() {
    console.log('üö™ Exiting splat scene...');
    isInSplatScene = false;
    
    // Re-enable main controls
    controls.enabled = true;
    splatControls.enabled = false;
    
    // ‚úÖ CRITICAL FIX: Switch splat viewer back to portal camera
    if (splatViewer) {
        // Update the viewer's camera reference back to portal camera
        splatViewer.camera = portalCamera;
        
        // Remove splat from main scene
        if (splatViewer.splatMesh) {
            scene.remove(splatViewer.splatMesh);
        }
        
        // Add splat back to portal scene
        if (splatViewer.splatMesh) {
            portalScene.add(splatViewer.splatMesh);
        }
    }
    
    // Reset camera to main scene
    camera.position.set(0, 1.6, 5);
    controls.target.set(0, 1.6, -3);
    controls.update();
    
    // Restore background
    scene.background = new THREE.Color(0x0a0a0a);
    
    // Show main scene objects
    floor.visible = true;
    backWall.visible = true;
    cube.visible = true;
    portalGroup.visible = true;
    
    // Restore instructions
    document.getElementById('instructions').innerHTML = `
        <h2>üåÄ Portal Controls</h2>
        <ul>
            <li>Left click + drag to orbit</li>
            <li>Scroll to zoom in/out</li>
            <li>Navigate closer to portal</li>
            <li>Click portal to enter!</li>
        </ul>
    `;
    
    console.log('‚úÖ Camera switched back to portal camera');
}

// Listen for ESC key to exit
window.addEventListener('keydown', (event) => {
    if (event.key === 'Escape' && isInSplatScene) {
        exitSplatScene();
    }
});

function animate() {
    requestAnimationFrame(animate);
    
    // Update appropriate controls
    if (isInSplatScene) {
        splatControls.update();
    } else {
        controls.update();
        updatePortalProximity();
        
        // Animate cube in main scene
        cube.rotation.x += 0.005;
        cube.rotation.y += 0.005;
        
        // Rotate portal camera (only when outside)
        portalCameraAngle += 0.002;
        portalCamera.position.x = Math.sin(portalCameraAngle) * 8;
        portalCamera.position.y = 2;
        portalCamera.position.z = Math.cos(portalCameraAngle) * 8;
        portalCamera.lookAt(0, 0, 0);
    }
    
    // ‚úÖ FIXED: Proper rendering logic for both modes
    if (splatViewer) {
        // Always update the viewer
        splatViewer.update();
        
        if (isInSplatScene) {
            // ‚úÖ When INSIDE: Render splat directly to screen with main camera
            renderer.setRenderTarget(null);
            splatViewer.render();
            
        } else {
            // ‚úÖ When OUTSIDE: Render splat to portal texture with portal camera
            renderer.setRenderTarget(portalRenderTarget);
            const time = Date.now() * 0.001;
glow.material.opacity = 0.2 + Math.sin(time * 2) * 0.1;  // Pulse between 0.1 and 0.3
            splatViewer.render();
            renderer.setRenderTarget(null);
            
            // Then render main scene with portal
            renderer.render(scene, camera);
        }
    } else {
        // Fallback if splat viewer not loaded
        if (!isInSplatScene) {
            renderer.setRenderTarget(portalRenderTarget);
            renderer.render(portalScene, portalCamera);
            renderer.setRenderTarget(null);
            renderer.render(scene, camera);
        } else {
            renderer.render(scene, camera);
        }
    }
}

        // ====== WINDOW RESIZE HANDLER ======
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            
            // Update portal render target size
            portalRenderTarget.setSize(
                Math.min(window.innerWidth, 2048),
                Math.min(window.innerHeight, 2048)
            );
        });

        // ====== START APPLICATION ======
        init().catch(err => {
            console.error('Init failed:', err);
            document.getElementById('loading-text').textContent = 'Error: ' + err.message;
        });
    </script>
</body>
</html>