<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gaussian Splat Gallery + Video Feed</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            overflow: hidden;
            background: #000;
        }
        #canvas-container {
            width: 100vw;
            height: 100vh;
        }
        #instructions {
            position: fixed;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            font-size: 14px;
            max-width: 300px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(74, 158, 255, 0.3);
            z-index: 100;
        }
        #instructions h2 {
            margin: 0 0 15px 0;
            font-size: 18px;
            color: #4a9eff;
        }
        #instructions ul {
            list-style: none;
            padding: 0;
        }
        #instructions li {
            margin: 8px 0;
            padding-left: 20px;
            position: relative;
        }
        #instructions li:before {
            content: "‚Üí";
            position: absolute;
            left: 0;
            color: #4a9eff;
        }
        #loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 20px;
            text-align: center;
            background: rgba(0, 0, 0, 0.8);
            padding: 30px;
            border-radius: 10px;
            min-width: 300px;
            z-index: 1000;
        }
        .spinner {
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-top: 3px solid #4a9eff;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        #portal-prompt {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            background: rgba(74, 158, 255, 0.9);
            padding: 20px 40px;
            border-radius: 10px;
            font-size: 18px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 200;
        }
        #portal-prompt.show {
            opacity: 1;
        }
        #file-info {
            position: fixed;
            bottom: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 8px;
            font-size: 12px;
            font-family: monospace;
            z-index: 100;
        }
        #gallery-info {
            position: fixed;
            top: 20px;
            right: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            font-size: 14px;
            max-width: 300px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(74, 158, 255, 0.3);
            z-index: 100;
        }
        #gallery-info h2 {
            margin: 0 0 15px 0;
            font-size: 18px;
            color: #4a9eff;
        }
        #hotspot-info {
            position: fixed;
            bottom: 20px;
            right: 20px;
            color: white;
            background: rgba(255, 102, 0, 0.9);
            padding: 15px;
            border-radius: 8px;
            font-size: 14px;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 100;
        }
        #hotspot-info.show {
            opacity: 1;
        }
        #hotspot-controls {
            position: fixed;
            bottom: 20px;
            right: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.9);
            padding: 20px;
            border-radius: 10px;
            font-size: 12px;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 100;
            max-width: 300px;
            border: 1px solid rgba(74, 158, 255, 0.3);
        }
        #hotspot-controls.show {
            opacity: 1;
        }
        #hotspot-controls h3 {
            margin: 0 0 15px 0;
            font-size: 14px;
            color: #4a9eff;
        }
        .hotspot-slider-group {
            margin-bottom: 15px;
            padding: 10px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 5px;
        }
        .hotspot-slider-group h4 {
            margin: 0 0 10px 0;
            font-size: 12px;
        }
        .cyan-group h4 {
            color: #00ffff;
        }
        .orange-group h4 {
            color: #ff6600;
        }
        .slider-row {
            display: flex;
            align-items: center;
            margin: 5px 0;
        }
        .slider-row label {
            width: 15px;
            font-weight: bold;
        }
        .slider-row input[type="range"] {
            flex: 1;
            margin: 0 8px;
            height: 20px;
        }
        .slider-row span {
            width: 40px;
            text-align: right;
            font-family: monospace;
            font-size: 11px;
        }
        .reset-btn {
            background: rgba(74, 158, 255, 0.8);
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 10px;
            margin-top: 5px;
        }
        .reset-btn:hover {
            background: rgba(74, 158, 255, 1);
        }
        
        /* VIDEO CONTROLS */
        #video-controls {
            position: fixed;
            bottom: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.9);
            padding: 20px;
            border-radius: 10px;
            font-size: 12px;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 100;
            max-width: 300px;
            border: 1px solid rgba(255, 0, 255, 0.5);
        }
        #video-controls.show {
            opacity: 1;
        }
        #video-controls h3 {
            margin: 0 0 15px 0;
            font-size: 14px;
            color: #ff00ff;
        }
        .video-button {
            background: rgba(255, 0, 255, 0.7);
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
            margin: 5px 5px 5px 0;
        }
        .video-button:hover {
            background: rgba(255, 0, 255, 1);
        }
        .video-button:disabled {
            background: rgba(100, 100, 100, 0.5);
            cursor: not-allowed;
        }
        
        /* Hidden video element for texture source */
        #hidden-video {
            display: none;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    
    <!-- Hidden video element for texture source -->
    <video id="hidden-video" muted playsinline crossorigin="anonymous"></video>
    
    <div id="loading">
        <div class="spinner"></div>
        <div id="loading-text">Loading Gallery...</div>
    </div>
    
    <div id="instructions" style="display: none;">
        <h2>üåÄ Gallery Controls</h2>
        <ul>
            <li>Left click + drag to orbit</li>
            <li>Scroll to zoom in/out</li>
            <li>Click any portal to enter</li>
            <li>Each portal shows different view</li>
        </ul>
    </div>
    
    <div id="gallery-info" style="display: none;">
        <h2>üìä Portal Description</h2>
        <div style="font-size: 12px; line-height: 1.8;">
            <div style="color: #4a9eff;">‚óè Portal 1: first test guass</div>
            <div style="color: #ff6b6b;">‚óè Portal 2: Sony A7S & SuperPoint SuperGlue method Nov 2nd (üéØ Interactive Hotspots)</div>
            <div style="color: #51cf66;">‚óè Portal 3: Reference + üé¨ VIDEO FEED!</div>
        </div>
    </div>
    
    <div id="file-info" style="display: none;">
        <div>üìÅ Gallery loaded successfully</div>
        <div>üé® <span id="portal-count">0</span> Portals Active</div>
        <div>üé¨ Video Feed Ready</div>
    </div>

    <div id="portal-prompt">
        Click portal to enter the 3D scene!
    </div>

    <div id="hotspot-info">
        üéØ Click glowing spheres! (Cyan=info.mp3, Orange=bass.mp3) Click again to stop!
    </div>

    <div id="hotspot-controls">
        <h3>üéØ Hotspot Position Controls</h3>
        
        <div class="hotspot-slider-group cyan-group">
            <h4>Cyan Hotspot (info.mp3)</h4>
            <div class="slider-row">
                <label>X:</label>
                <input type="range" id="cyan-x" min="-12" max="12" step="0.1" value="7">
                <span id="cyan-x-val">7.0</span>
            </div>
            <div class="slider-row">
                <label>Y:</label>
                <input type="range" id="cyan-y" min="-4" max="4" step="0.1" value="-2">
                <span id="cyan-y-val">-2.0</span>
            </div>
            <div class="slider-row">
                <label>Z:</label>
                <input type="range" id="cyan-z" min="-4" max="10" step="0.1" value="-2">
                <span id="cyan-z-val">-2.0</span>
            </div>
            <button class="reset-btn" onclick="resetCyanPosition()">Reset</button>
        </div>

        <div class="hotspot-slider-group orange-group">
            <h4>Orange Hotspot (bass.mp3)</h4>
            <div class="slider-row">
                <label>X:</label>
                <input type="range" id="orange-x" min="-12" max="12" step="0.1" value="-2.5">
                <span id="orange-x-val">-2.5</span>
            </div>
            <div class="slider-row">
                <label>Y:</label>
                <input type="range" id="orange-y" min="-4" max="4" step="0.1" value="-3">
                <span id="orange-y-val">-3.0</span>
            </div>
            <div class="slider-row">
                <label>Z:</label>
                <input type="range" id="orange-z" min="-4" max="10" step="0.1" value="8.1">
                <span id="orange-z-val">8.1</span>
            </div>
            <button class="reset-btn" onclick="resetOrangePosition()">Reset</button>
        </div>
        
        <div style="margin-top: 15px; font-size: 10px; color: #ccc;">
            Move sliders to position hotspots! Range: X/Y ¬±12/¬±4, Z -4‚Üí10
        </div>
    </div>

    <!-- NEW: Video Controls -->
    <div id="video-controls">
        <h3>üé¨ Video Feed Controls</h3>
        <div style="margin-bottom: 15px;">
            <label style="display: block; margin-bottom: 5px; font-size: 11px; color: #ccc;">Video URL:</label>
            <input type="text" id="video-url-input" placeholder="Enter video URL (mp4, webm, etc.)" 
                   style="width: 100%; padding: 5px; border-radius: 3px; border: 1px solid #444; background: #222; color: white; font-size: 11px;">
            <button class="video-button" style="margin-top: 5px; font-size: 10px;" onclick="loadVideoFromURL()">üîó Load URL</button>
        </div>
        <div>
            <button class="video-button" id="webcam-btn" onclick="startWebcam()">üì∑ Start Webcam</button>
            <button class="video-button" id="test-video-btn" onclick="loadTestVideo()">üé• Test Video</button>
        </div>
        <div style="margin-top: 10px;">
            <button class="video-button" id="stop-video-btn" onclick="stopVideo()" disabled>‚èπÔ∏è Stop Video</button>
        </div>
        
        <!-- Video Position Controls -->
        <div style="margin-top: 15px; padding: 10px; border: 1px solid rgba(255, 0, 255, 0.3); border-radius: 5px;">
            <h4 style="margin: 0 0 10px 0; font-size: 12px; color: #ff00ff;">üì∫ Video Screen Position</h4>
            <div class="slider-row">
                <label style="width: 15px; font-weight: bold; color: #ff00ff;">X:</label>
                <input type="range" id="video-x" min="-8" max="8" step="0.1" value="0">
                <span id="video-x-val" style="width: 40px; text-align: right; font-family: monospace; font-size: 11px;">0.0</span>
            </div>
            <div class="slider-row">
                <label style="width: 15px; font-weight: bold; color: #ff00ff;">Y:</label>
                <input type="range" id="video-y" min="-4" max="6" step="0.1" value="1">
                <span id="video-y-val" style="width: 40px; text-align: right; font-family: monospace; font-size: 11px;">1.0</span>
            </div>
            <div class="slider-row">
                <label style="width: 15px; font-weight: bold; color: #ff00ff;">Z:</label>
                <input type="range" id="video-z" min="-20" max="20" step="0.1" value="2">
                <span id="video-z-val" style="width: 40px; text-align: right; font-family: monospace; font-size: 11px;">2.0</span>
            </div>
            <div class="slider-row">
                <label style="width: 15px; font-weight: bold; color: #ff00ff;">S:</label>
                <input type="range" id="video-scale" min="0.1" max="5.0" step="0.1" value="1.0">
                <span id="video-scale-val" style="width: 40px; text-align: right; font-family: monospace; font-size: 11px;">1.0</span>
            </div>
            <button class="reset-btn" style="background: rgba(255, 0, 255, 0.7);" onclick="resetVideoPosition()">Reset Position</button>
        </div>
        
        <div style="margin-top: 15px; font-size: 9px; color: #ccc; line-height: 1.3;">
            Video appears as floating screen in Portal 3!<br>
            <strong>Controls:</strong> Position (X,Y,Z) + Scale (0.1x - 5.0x)<br>
            <strong>Example URLs:</strong><br>
            ‚Ä¢ https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4<br>
            ‚Ä¢ https://sample-videos.com/zip/10/mp4/SampleVideo_1280x720_1mb.mp4<br>
            ‚Ä¢ Local: ./myvideo.mp4
        </div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import * as GaussianSplats3D from 'https://cdn.jsdelivr.net/npm/@mkkellogg/gaussian-splats-3d@latest/build/gaussian-splats-3d.module.min.js';

        // ====== VIDEO SYSTEM ======
        let videoElement = document.getElementById('hidden-video');
        let videoTexture = null;
        let videoScreen = null;
        let videoMaterial = null;
        let isVideoActive = false;

        // Video positioning system
        let videoPosition = { x: 0, y: 1, z: 2 }; // Default position
        let videoScale = 1.0; // Default scale

        // ====== PORTAL CONFIGURATION ======
        const PORTAL_CONFIGS = [
            {
                name: "First Guassian Test iPhone and Record3D",
                splatFile: "https://huggingface.co/mysterytreebeast/gaussian-splat-models/resolve/main/frontroom_1506.ply",
                position: { x: -5, y: 0.5, z: -5 },
                color: 0x4a9eff,
                parallaxStrength: 0.5,
                scale: 5
            },
            {
                name: "Sony A7 photoset morning",
                splatFile: "https://huggingface.co/mysterytreebeast/gaussian-splat-models/resolve/main/02112025Morning.ply",
                position: { x: 0, y: 0.5, z: -6 },
                color: 0xff6b6b,
                parallaxStrength: 0.3,
                scale: 5
            },
            {
                name: "Reference + Video Feed",
                splatFile: "https://huggingface.co/mysterytreebeast/gaussian-splat-models/resolve/main/InteriorDesign.ply",
                position: { x: 5, y: 0.5, z: -5 },
                color: 0x51cf66,
                parallaxStrength: 0.1,
                scale: 5
            }
        ];

        // ====== MAIN SCENE SETUP ======
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0a0a);

        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 1.6, 8);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        document.getElementById('canvas-container').appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 3;
        controls.maxDistance = 20;
        controls.maxPolarAngle = Math.PI / 2;
        controls.target.set(0, 0.8, -3);

        // ====== VIDEO FUNCTIONS ======
        function createVideoScreen() {
            console.log('üé¨ Creating video screen...');
            console.log('Video element state:', {
                videoWidth: videoElement.videoWidth,
                videoHeight: videoElement.videoHeight,
                readyState: videoElement.readyState,
                paused: videoElement.paused,
                currentTime: videoElement.currentTime
            });
            
            // Create video texture with proper settings
            videoTexture = new THREE.VideoTexture(videoElement);
            videoTexture.minFilter = THREE.LinearFilter;
            videoTexture.magFilter = THREE.LinearFilter;
            videoTexture.format = THREE.RGBAFormat;
            videoTexture.generateMipmaps = false;
            videoTexture.wrapS = THREE.ClampToEdgeWrapping;
            videoTexture.wrapT = THREE.ClampToEdgeWrapping;
            
            // Create video material
            videoMaterial = new THREE.MeshBasicMaterial({ 
                map: videoTexture,
                side: THREE.DoubleSide,
                transparent: false
            });
            
            // Create video screen (16:9 aspect ratio) - this is the main mesh
            const screenGeometry = new THREE.PlaneGeometry(4, 2.25);
            videoScreen = new THREE.Mesh(screenGeometry, videoMaterial);
            videoScreen.position.set(videoPosition.x, videoPosition.y, videoPosition.z);
            videoScreen.scale.set(videoScale, videoScale, videoScale);
            videoScreen.userData = { isVideoScreen: true };
            
            console.log('‚úÖ Video screen created at position:', videoScreen.position, 'with scale:', videoScale);
            return videoScreen; // Return just the mesh, not a group
        }

        function addVideoToPortal(portalIndex = 2) {
            const portal = portals[portalIndex];
            if (portal && portal.scene && videoScreen) {
                // Remove from any previous parent
                if (videoScreen.parent) {
                    videoScreen.parent.remove(videoScreen);
                }
                
                // Add to portal scene
                portal.scene.add(videoScreen);
                console.log(`üé¨ Video screen added to portal ${portalIndex}`);
            }
        }

        function removeVideoFromPortal() {
            if (videoScreen && videoScreen.parent) {
                videoScreen.parent.remove(videoScreen);
                console.log('üé¨ Video screen removed from portal');
            }
        }

        // Video control functions (made global for HTML buttons)
        window.loadVideoFromURL = function() {
            const urlInput = document.getElementById('video-url-input');
            const videoUrl = urlInput.value.trim();
            
            if (!videoUrl) {
                alert('Please enter a video URL');
                return;
            }
            
            try {
                console.log('üîó Loading video from URL:', videoUrl);
                
                // Stop any existing video first
                if (videoElement.srcObject) {
                    const stream = videoElement.srcObject;
                    const tracks = stream.getTracks();
                    tracks.forEach(track => track.stop());
                    videoElement.srcObject = null;
                }
                
                // Set video source to URL
                videoElement.src = videoUrl;
                videoElement.crossOrigin = "anonymous"; // For CORS
                videoElement.loop = true; // Loop the video
                videoElement.muted = true; // Start muted (browser autoplay policy)
                videoElement.play();
                
                if (!videoScreen) {
                    createVideoScreen();
                }
                
                isVideoActive = true;
                
                document.getElementById('webcam-btn').disabled = true;
                document.getElementById('test-video-btn').disabled = true;
                document.getElementById('stop-video-btn').disabled = false;
                
                console.log('‚úÖ Video URL loaded successfully');
                
                // Add video to portal 3 if we're currently in it
                if (activePortalIndex === 2) {
                    addVideoToPortal(2);
                }
                
            } catch (error) {
                console.error('‚ùå Video URL loading failed:', error);
                alert(`Failed to load video: ${error.message}`);
            }
        };

        window.startWebcam = async function() {
            try {
                console.log('üì∑ Starting webcam...');
                
                // Stop any existing video first
                if (videoElement.srcObject) {
                    const stream = videoElement.srcObject;
                    const tracks = stream.getTracks();
                    tracks.forEach(track => track.stop());
                }
                
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { 
                        width: { ideal: 1280 }, 
                        height: { ideal: 720 },
                        facingMode: 'user'
                    },
                    audio: false 
                });
                
                console.log('üìπ Webcam stream acquired:', stream);
                console.log('Video tracks:', stream.getVideoTracks());
                
                videoElement.srcObject = stream;
                videoElement.muted = true;
                videoElement.autoplay = true;
                videoElement.playsInline = true;
                
                // Wait for video to be ready
                videoElement.onloadedmetadata = () => {
                    console.log('üì∫ Webcam metadata loaded:', {
                        videoWidth: videoElement.videoWidth,
                        videoHeight: videoElement.videoHeight
                    });
                    
                    videoElement.play().then(() => {
                        console.log('‚úÖ Webcam playing successfully');
                    }).catch(err => {
                        console.error('‚ùå Webcam play failed:', err);
                    });
                };
                
                if (!videoScreen) {
                    createVideoScreen();
                }
                
                isVideoActive = true;
                
                document.getElementById('webcam-btn').disabled = true;
                document.getElementById('test-video-btn').disabled = true;
                document.getElementById('stop-video-btn').disabled = false;
                
                console.log('‚úÖ Webcam started successfully');
                
                // Add video to portal 3 if we're currently in it
                if (activePortalIndex === 2) {
                    addVideoToPortal(2);
                }
                
            } catch (error) {
                console.error('‚ùå Webcam access failed:', error);
                let errorMsg = 'Could not access webcam.';
                
                if (error.name === 'NotAllowedError') {
                    errorMsg += ' Please check camera permissions.';
                } else if (error.name === 'NotFoundError') {
                    errorMsg += ' No camera found.';
                } else if (error.name === 'OverconstrainedError') {
                    errorMsg += ' Camera constraints not supported.';
                } else {
                    errorMsg += ` Error: ${error.message}`;
                }
                
                alert(errorMsg);
            }
        };

        window.loadTestVideo = function() {
            try {
                console.log('üé• Loading test video...');
                
                // Stop any existing video first
                if (videoElement.srcObject) {
                    const stream = videoElement.srcObject;
                    const tracks = stream.getTracks();
                    tracks.forEach(track => track.stop());
                    videoElement.srcObject = null;
                }
                
                // Create a larger test video canvas for better visibility
                const canvas = document.createElement('canvas');
                canvas.width = 640;
                canvas.height = 360;
                const ctx = canvas.getContext('2d');
                
                console.log('üì∫ Canvas created:', canvas.width + 'x' + canvas.height);
                
                // Create animated color bars with debugging info
                function drawColorBars() {
                    const time = Date.now() * 0.001;
                    
                    // Clear canvas with black background
                    ctx.fillStyle = '#000000';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw animated color bars
                    const colors = ['#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff', '#00ffff', '#ffffff'];
                    
                    for (let i = 0; i < colors.length; i++) {
                        ctx.fillStyle = colors[i];
                        const barWidth = canvas.width / colors.length;
                        const barHeight = canvas.height * 0.6;
                        const yOffset = canvas.height * 0.2;
                        const animOffset = Math.sin(time * 2 + i * 0.5) * 20;
                        
                        ctx.fillRect(i * barWidth, yOffset + animOffset, barWidth - 2, barHeight);
                    }
                    
                    // Add large visible text
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 32px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('TEST VIDEO', canvas.width/2, 40);
                    
                    // Add timestamp
                    ctx.font = 'bold 24px Arial';
                    ctx.fillText(`Time: ${time.toFixed(1)}s`, canvas.width/2, canvas.height - 20);
                    
                    // Add frame counter
                    ctx.font = '16px Arial';
                    ctx.fillText(`Frame: ${Math.floor(time * 30)}`, canvas.width/2, canvas.height - 50);
                    
                    requestAnimationFrame(drawColorBars);
                }
                
                drawColorBars();
                
                // Create video stream from canvas with explicit frame rate
                const stream = canvas.captureStream(30);
                console.log('üé¨ Canvas stream created:', stream);
                console.log('Stream tracks:', stream.getTracks());
                
                // Set up video element properly
                videoElement.srcObject = stream;
                videoElement.muted = true;
                videoElement.loop = true;
                videoElement.autoplay = true;
                videoElement.playsInline = true;
                
                // Wait for video to be ready then play
                videoElement.onloadedmetadata = () => {
                    console.log('üì∫ Video metadata loaded:', {
                        videoWidth: videoElement.videoWidth,
                        videoHeight: videoElement.videoHeight,
                        duration: videoElement.duration
                    });
                    videoElement.play().then(() => {
                        console.log('‚úÖ Video playing successfully');
                    }).catch(err => {
                        console.error('‚ùå Video play failed:', err);
                    });
                };
                
                if (!videoScreen) {
                    createVideoScreen();
                }
                
                isVideoActive = true;
                
                document.getElementById('webcam-btn').disabled = true;
                document.getElementById('test-video-btn').disabled = true;
                document.getElementById('stop-video-btn').disabled = false;
                
                console.log('‚úÖ Test video setup complete');
                
                // Add video to portal 3 if we're currently in it
                if (activePortalIndex === 2) {
                    addVideoToPortal(2);
                }
                
            } catch (error) {
                console.error('‚ùå Test video creation failed:', error);
                alert(`Test video failed: ${error.message}`);
            }
        };

        window.stopVideo = function() {
            console.log('‚èπÔ∏è Stopping video...');
            
            if (videoElement.srcObject) {
                const stream = videoElement.srcObject;
                const tracks = stream.getTracks();
                tracks.forEach(track => track.stop());
                videoElement.srcObject = null;
            }
            
            removeVideoFromPortal();
            isVideoActive = false;
            
            document.getElementById('webcam-btn').disabled = false;
            document.getElementById('test-video-btn').disabled = false;
            document.getElementById('stop-video-btn').disabled = true;
            
            console.log('‚úÖ Video stopped');
        };

        // ====== LIGHTING SETUP ======
        scene.add(new THREE.AmbientLight(0x111111, 0.2));

        const spotlight1 = new THREE.SpotLight(0x4a9eff, 10);
        spotlight1.position.set(-5, 8, -3);
        spotlight1.angle = Math.PI / 5;
        spotlight1.penumbra = 0.6;
        spotlight1.decay = 1.5;
        spotlight1.distance = 20;
        spotlight1.castShadow = true;
        spotlight1.target.position.set(-5, 0.5, -5);
        scene.add(spotlight1);
        scene.add(spotlight1.target);

        const spotlight2 = new THREE.SpotLight(0xff3333, 10);
        spotlight2.position.set(0, 8, -4);
        spotlight2.angle = Math.PI / 5;
        spotlight2.penumbra = 0.6;
        spotlight2.decay = 1.5;
        spotlight2.distance = 20;
        spotlight2.castShadow = true;
        spotlight2.target.position.set(0, 0.5, -6);
        scene.add(spotlight2);
        scene.add(spotlight2.target);

        const spotlight3 = new THREE.SpotLight(0xaaccff, 10);
        spotlight3.position.set(5, 8, -3);
        spotlight3.angle = Math.PI / 5;
        spotlight3.penumbra = 0.7;
        spotlight3.decay = 1.5;
        spotlight3.distance = 20;
        spotlight3.castShadow = true;
        spotlight3.target.position.set(5, 0.5, -5);
        scene.add(spotlight3);
        scene.add(spotlight3.target);

        // ====== ROOM GEOMETRY ======
        const floor = new THREE.Mesh(
            new THREE.PlaneGeometry(30, 30),
            new THREE.MeshStandardMaterial({ color: 0x1fffff })
        );
        floor.rotation.x = -Math.PI / 2;
        floor.position.y = -1;
        floor.receiveShadow = true;
        scene.add(floor);

        const wallMat = new THREE.MeshStandardMaterial({ 
            color: 0xffffff, 
            side: THREE.DoubleSide 
        });
        const backWall = new THREE.Mesh(new THREE.PlaneGeometry(30, 10), wallMat);
        backWall.position.set(0, 4, -8);
        backWall.receiveShadow = true;
        scene.add(backWall);

        const leftWall = new THREE.Mesh(new THREE.PlaneGeometry(20, 10), wallMat);
        leftWall.position.set(-10, 4, 0);
        leftWall.rotation.y = Math.PI / 2;
        leftWall.receiveShadow = true;
        scene.add(leftWall);

        const rightWall = new THREE.Mesh(new THREE.PlaneGeometry(20, 10), wallMat);
        rightWall.position.set(10, 4, 0);
        rightWall.rotation.y = -Math.PI / 2;
        rightWall.receiveShadow = true;
        scene.add(rightWall);

        const cube = new THREE.Mesh(
            new THREE.BoxGeometry(0.8, 0.8, 0.8),
            new THREE.MeshStandardMaterial({ color: 0xFFFF00 })
        );
        cube.position.set(-1, 0, -5);
        cube.castShadow = true;
        cube.receiveShadow = true;
        scene.add(cube);

        // ====== PORTAL SYSTEM ======
        const portals = [];
        let activePortalIndex = -1;
        let isInSplatScene = false;
        let splatControls = null;

        // ====== HOTSPOT SYSTEM ======
        const hotspots = [];
        let audioContext = null;
        let currentlyPlayingAudio = [null, null];
        let currentlyPlayingType = [null, null];
        let hotspotPositions = [
            { x: 7, y: -2, z: -2 },
            { x: 2.8, y: -3, z: 6.8 }
        ];
        
        const AUDIO_FILES = ['info.mp3', 'bass.mp3'];

        // Audio and hotspot functions
        function createSyntheticAudio(audioIndex) {
            if (!audioContext) return null;
            
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            const frequencies = [800, 400];
            const frequency = frequencies[audioIndex] || 440;
            
            oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
            oscillator.type = 'sine';
            
            gainNode.gain.setValueAtTime(0, audioContext.currentTime);
            gainNode.gain.linearRampToValueAtTime(0.3, audioContext.currentTime + 0.1);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.8);
            
            oscillator.start();
            oscillator.stop(audioContext.currentTime + 0.8);
            
            return oscillator;
        }

        function initAudioContext() {
            if (!audioContext) {
                try {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                } catch (e) {
                    console.warn('AudioContext not supported, falling back to HTML5 Audio');
                }
            }
        }

        async function playAudio(audioIndex) {
            console.log(`üîä Audio control for hotspot ${audioIndex + 1}`);
            
            if (currentlyPlayingAudio[audioIndex]) {
                stopAudio(audioIndex);
                return;
            }
            
            try {
                initAudioContext();
                
                if (audioContext && audioContext.state === 'suspended') {
                    await audioContext.resume();
                }

                const audioUrl = AUDIO_FILES[audioIndex];
                
                if (audioUrl) {
                    try {
                        const response = await fetch(audioUrl);
                        const arrayBuffer = await response.arrayBuffer();
                        const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                        
                        const source = audioContext.createBufferSource();
                        source.buffer = audioBuffer;
                        source.connect(audioContext.destination);
                        
                        currentlyPlayingAudio[audioIndex] = source;
                        currentlyPlayingType[audioIndex] = 'file';
                        
                        source.onended = () => {
                            currentlyPlayingAudio[audioIndex] = null;
                            currentlyPlayingType[audioIndex] = null;
                        };
                        
                        source.start();
                        console.log('‚úÖ External audio file playing');
                        
                        showAudioFeedback(audioIndex, 'file');
                        return;
                    } catch (fetchError) {
                        console.warn('External audio failed, using synthetic audio:', fetchError);
                    }
                }
                
                if (audioContext) {
                    const oscillator = createSyntheticAudio(audioIndex);
                    if (oscillator) {
                        currentlyPlayingAudio[audioIndex] = oscillator;
                        currentlyPlayingType[audioIndex] = 'synthetic';
                        
                        oscillator.onended = () => {
                            currentlyPlayingAudio[audioIndex] = null;
                            currentlyPlayingType[audioIndex] = null;
                        };
                        
                        console.log('‚úÖ Synthetic audio playing');
                        showAudioFeedback(audioIndex, 'synthetic');
                    }
                } else {
                    throw new Error('No AudioContext available');
                }
                
            } catch (error) {
                console.error('All audio methods failed:', error);
                showAudioFeedback(audioIndex, 'visual');
            }
        }

        function stopAudio(audioIndex) {
            const audioSource = currentlyPlayingAudio[audioIndex];
            const audioType = currentlyPlayingType[audioIndex];
            
            if (audioSource) {
                try {
                    if (audioType === 'file' || audioType === 'synthetic') {
                        audioSource.stop();
                    }
                    console.log(`üõë Stopped audio for hotspot ${audioIndex + 1}`);
                } catch (e) {
                    console.warn('Error stopping audio:', e);
                }
                
                currentlyPlayingAudio[audioIndex] = null;
                currentlyPlayingType[audioIndex] = null;
                
                showStopFeedback(audioIndex);
            }
        }

        function showAudioFeedback(audioIndex, audioType = 'visual') {
            const feedback = document.createElement('div');
            feedback.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(74, 158, 255, 0.95);
                color: white;
                padding: 20px 30px;
                border-radius: 10px;
                z-index: 1000;
                font-size: 16px;
                text-align: center;
                border: 2px solid rgba(255, 255, 255, 0.3);
            `;
            
            let message = '';
            if (audioType === 'file') {
                const fileName = audioIndex === 0 ? 'info.mp3' : 'bass.mp3';
                const hotspotColor = audioIndex === 0 ? 'Cyan' : 'Orange';
                message = `üéµ ${hotspotColor} Hotspot\n‚ñ∂Ô∏è Playing: ${fileName}\n\n(Click again to stop)`;
            } else if (audioType === 'synthetic') {
                const hotspotName = audioIndex === 0 ? 'Cyan Hotspot' : 'Orange Hotspot';
                const pitch = audioIndex === 0 ? 'High Tone' : 'Low Tone';
                message = `üîä ${hotspotName}\n‚ñ∂Ô∏è ${pitch} Playing!\n\n(Click again to stop)`;
            } else {
                const fileName = audioIndex === 0 ? 'info.mp3' : 'bass.mp3';
                const hotspotColor = audioIndex === 0 ? 'Cyan' : 'Orange';
                message = `üéØ ${hotspotColor} Hotspot\n${fileName} would play here`;
            }
            
            feedback.textContent = message;
            feedback.style.whiteSpace = 'pre-line';
            document.body.appendChild(feedback);
            
            setTimeout(() => {
                if (document.body.contains(feedback)) {
                    document.body.removeChild(feedback);
                }
            }, 2000);
        }

        function showStopFeedback(audioIndex) {
            const feedback = document.createElement('div');
            feedback.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(255, 102, 0, 0.95);
                color: white;
                padding: 20px 30px;
                border-radius: 10px;
                z-index: 1000;
                font-size: 16px;
                text-align: center;
                border: 2px solid rgba(255, 255, 255, 0.3);
            `;
            
            const fileName = audioIndex === 0 ? 'info.mp3' : 'bass.mp3';
            const hotspotColor = audioIndex === 0 ? 'Cyan' : 'Orange';
            const message = `üõë ${hotspotColor} Hotspot\n‚èπÔ∏è Stopped: ${fileName}\n\n(Click again to play)`;
            
            feedback.textContent = message;
            feedback.style.whiteSpace = 'pre-line';
            document.body.appendChild(feedback);
            
            setTimeout(() => {
                if (document.body.contains(feedback)) {
                    document.body.removeChild(feedback);
                }
            }, 1500);
        }

        function createHotspots() {
            console.log('üéØ Creating hotspots...');
            
            const hotspot1Geometry = new THREE.SphereGeometry(0.4, 16, 16);
            const hotspot1Material = new THREE.MeshBasicMaterial({ 
                color: 0x00ffff,
                transparent: true,
                opacity: 1.0,
                emissive: 0x003333
            });
            const hotspot1 = new THREE.Mesh(hotspot1Geometry, hotspot1Material);
            hotspot1.position.set(hotspotPositions[0].x, hotspotPositions[0].y, hotspotPositions[0].z);
            hotspot1.userData = { 
                isHotspot: true, 
                audioIndex: 0,
                name: 'Audio Point 1'
            };
            
            const hotspot1Glow = new THREE.Mesh(
                new THREE.SphereGeometry(0.6, 16, 16),
                new THREE.MeshBasicMaterial({ 
                    color: 0x00ffff,
                    transparent: true,
                    opacity: 0.5,
                    emissive: 0x001111
                })
            );
            hotspot1Glow.position.copy(hotspot1.position);
            
            const hotspot2Geometry = new THREE.SphereGeometry(0.4, 16, 16);
            const hotspot2Material = new THREE.MeshBasicMaterial({ 
                color: 0xff6600,
                transparent: true,
                opacity: 1.0,
                emissive: 0x331100
            });
            const hotspot2 = new THREE.Mesh(hotspot2Geometry, hotspot2Material);
            hotspot2.position.set(hotspotPositions[1].x, hotspotPositions[1].y, hotspotPositions[1].z);
            hotspot2.userData = { 
                isHotspot: true, 
                audioIndex: 1,
                name: 'Audio Point 2'
            };
            
            const hotspot2Glow = new THREE.Mesh(
                new THREE.SphereGeometry(0.6, 16, 16),
                new THREE.MeshBasicMaterial({ 
                    color: 0xff6600,
                    transparent: true,
                    opacity: 0.5,
                    emissive: 0x110000
                })
            );
            hotspot2Glow.position.copy(hotspot2.position);

            scene.add(hotspot1);
            scene.add(hotspot1Glow);
            scene.add(hotspot2);
            scene.add(hotspot2Glow);
            
            hotspot1.visible = false;
            hotspot1Glow.visible = false;
            hotspot2.visible = false;
            hotspot2Glow.visible = false;

            hotspots.push({
                sphere: hotspot1,
                glow: hotspot1Glow,
                audioIndex: 0,
                name: 'Audio Point 1'
            });
            
            hotspots.push({
                sphere: hotspot2,
                glow: hotspot2Glow,
                audioIndex: 1,
                name: 'Audio Point 2'
            });

            console.log('‚úÖ Hotspots created with enhanced visibility');
            initializeSliderControls();
            initializeVideoSliderControls(); // Initialize video position sliders
        }

        function initializeSliderControls() {
            const cyanXSlider = document.getElementById('cyan-x');
            const cyanYSlider = document.getElementById('cyan-y');
            const cyanZSlider = document.getElementById('cyan-z');
            const cyanXVal = document.getElementById('cyan-x-val');
            const cyanYVal = document.getElementById('cyan-y-val');
            const cyanZVal = document.getElementById('cyan-z-val');

            const orangeXSlider = document.getElementById('orange-x');
            const orangeYSlider = document.getElementById('orange-y');
            const orangeZSlider = document.getElementById('orange-z');
            const orangeXVal = document.getElementById('orange-x-val');
            const orangeYVal = document.getElementById('orange-y-val');
            const orangeZVal = document.getElementById('orange-z-val');

            function updateCyanPosition() {
                const x = parseFloat(cyanXSlider.value);
                const y = parseFloat(cyanYSlider.value);
                const z = parseFloat(cyanZSlider.value);
                
                hotspotPositions[0] = { x, y, z };
                
                if (hotspots[0]) {
                    hotspots[0].sphere.position.set(x, y, z);
                    hotspots[0].glow.position.set(x, y, z);
                }
                
                cyanXVal.textContent = x.toFixed(1);
                cyanYVal.textContent = y.toFixed(1);
                cyanZVal.textContent = z.toFixed(1);
            }

            function updateOrangePosition() {
                const x = parseFloat(orangeXSlider.value);
                const y = parseFloat(orangeYSlider.value);
                const z = parseFloat(orangeZSlider.value);
                
                hotspotPositions[1] = { x, y, z };
                
                if (hotspots[1]) {
                    hotspots[1].sphere.position.set(x, y, z);
                    hotspots[1].glow.position.set(x, y, z);
                }
                
                orangeXVal.textContent = x.toFixed(1);
                orangeYVal.textContent = y.toFixed(1);
                orangeZVal.textContent = z.toFixed(1);
            }

            cyanXSlider.addEventListener('input', updateCyanPosition);
            cyanYSlider.addEventListener('input', updateCyanPosition);
            cyanZSlider.addEventListener('input', updateCyanPosition);
            orangeXSlider.addEventListener('input', updateOrangePosition);
            orangeYSlider.addEventListener('input', updateOrangePosition);
            orangeZSlider.addEventListener('input', updateOrangePosition);

            console.log('‚úÖ Slider controls initialized');
        }

        function resetCyanPosition() {
            document.getElementById('cyan-x').value = 7;
            document.getElementById('cyan-y').value = -2;
            document.getElementById('cyan-z').value = -2;
            
            hotspotPositions[0] = { x: 7, y: -2, z: -2 };
            
            if (hotspots[0]) {
                hotspots[0].sphere.position.set(7, -2, -2);
                hotspots[0].glow.position.set(7, -2, -2);
            }
            
            document.getElementById('cyan-x-val').textContent = '7.0';
            document.getElementById('cyan-y-val').textContent = '-2.0';
            document.getElementById('cyan-z-val').textContent = '-2.0';
        }

        function resetOrangePosition() {
            document.getElementById('orange-x').value = -2.5;
            document.getElementById('orange-y').value = -3;
            document.getElementById('orange-z').value = 8.1;
            
            hotspotPositions[1] = { x: -2.5, y: -3, z: 8.1 };
            
            if (hotspots[1]) {
                hotspots[1].sphere.position.set(-2.5, -3, 8.1);
                hotspots[1].glow.position.set(-2.5, -3, 8.1);
            }
            
            document.getElementById('orange-x-val').textContent = '-2.5';
            document.getElementById('orange-y-val').textContent = '-3.0';
            document.getElementById('orange-z-val').textContent = '8.1';
        }

        window.resetCyanPosition = resetCyanPosition;
        window.resetOrangePosition = resetOrangePosition;

        // Video positioning functions
        function updateVideoPosition() {
            const videoXSlider = document.getElementById('video-x');
            const videoYSlider = document.getElementById('video-y');
            const videoZSlider = document.getElementById('video-z');
            const videoScaleSlider = document.getElementById('video-scale');
            const videoXVal = document.getElementById('video-x-val');
            const videoYVal = document.getElementById('video-y-val');
            const videoZVal = document.getElementById('video-z-val');
            const videoScaleVal = document.getElementById('video-scale-val');

            const x = parseFloat(videoXSlider.value);
            const y = parseFloat(videoYSlider.value);
            const z = parseFloat(videoZSlider.value);
            const scale = parseFloat(videoScaleSlider.value);
            
            // Update global position and scale tracking
            videoPosition = { x, y, z };
            videoScale = scale;
            
            // Update video screen position and scale if it exists
            if (videoScreen) {
                videoScreen.position.set(x, y, z);
                videoScreen.scale.set(scale, scale, scale);
                console.log(`üì∫ Video screen moved to: (${x}, ${y}, ${z}) with scale: ${scale}`);
            }
            
            // Update display values
            videoXVal.textContent = x.toFixed(1);
            videoYVal.textContent = y.toFixed(1);
            videoZVal.textContent = z.toFixed(1);
            videoScaleVal.textContent = scale.toFixed(1);
        }

        function initializeVideoSliderControls() {
            // Check if sliders exist
            const videoXSlider = document.getElementById('video-x');
            const videoYSlider = document.getElementById('video-y');
            const videoZSlider = document.getElementById('video-z');
            const videoScaleSlider = document.getElementById('video-scale');

            if (!videoXSlider || !videoYSlider || !videoZSlider || !videoScaleSlider) {
                console.warn('‚ö†Ô∏è Video sliders not found in DOM, retrying in 100ms...');
                setTimeout(initializeVideoSliderControls, 100);
                return;
            }

            // Remove existing listeners to avoid duplicates
            videoXSlider.removeEventListener('input', updateVideoPosition);
            videoYSlider.removeEventListener('input', updateVideoPosition);
            videoZSlider.removeEventListener('input', updateVideoPosition);
            videoScaleSlider.removeEventListener('input', updateVideoPosition);

            // Add event listeners
            videoXSlider.addEventListener('input', updateVideoPosition);
            videoYSlider.addEventListener('input', updateVideoPosition);
            videoZSlider.addEventListener('input', updateVideoPosition);
            videoScaleSlider.addEventListener('input', updateVideoPosition);

            console.log('‚úÖ Video slider controls (including scale) initialized and connected');
            
            // Test the sliders with a debug message
            videoXSlider.addEventListener('input', () => {
                console.log('üéõÔ∏è X slider changed to:', videoXSlider.value);
            });
            
            videoScaleSlider.addEventListener('input', () => {
                console.log('üéõÔ∏è Scale slider changed to:', videoScaleSlider.value);
            });
            
            // Initialize display values
            updateVideoPosition();
        }

        function resetVideoPosition() {
            document.getElementById('video-x').value = 0;
            document.getElementById('video-y').value = 1;
            document.getElementById('video-z').value = 2;
            document.getElementById('video-scale').value = 1.0;
            
            videoPosition = { x: 0, y: 1, z: 2 };
            videoScale = 1.0;
            
            if (videoScreen) {
                videoScreen.position.set(0, 1, 2);
                videoScreen.scale.set(1.0, 1.0, 1.0);
                console.log('üì∫ Video screen reset to default position (0, 1, 2) and scale (1.0)');
            }
            
            // Update display values
            updateVideoPosition();
        }

        window.resetVideoPosition = resetVideoPosition;

        function createSplatControls() {
            const controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 0.5;
            controls.maxDistance = 50;
            controls.enabled = false;
            return controls;
        }

        splatControls = createSplatControls();

        async function createPortal(config, index) {
            console.log(`\nüî∑ Creating portal ${index}: ${config.name}`);

            const portalScene = new THREE.Scene();
            portalScene.background = new THREE.Color(0x1a1a2a);
            
            const portalCamera = new THREE.PerspectiveCamera(60, 1, 0.1, 100);
            portalCamera.position.set(0, 1, 3);
            portalCamera.lookAt(0, 0, 0);
            
            portalScene.add(new THREE.AmbientLight(0xffffff, 0.8));
            const portalDirLight = new THREE.DirectionalLight(0xffffff, 0.5);
            portalDirLight.position.set(5, 5, 5);
            portalScene.add(portalDirLight);
            
            const portalRenderTarget = new THREE.WebGLRenderTarget(2048, 2048, {
                minFilter: THREE.LinearFilter,
                magFilter: THREE.LinearFilter,
                format: THREE.RGBAFormat
            });

            const portalGroup = new THREE.Group();
            portalGroup.position.set(config.position.x, config.position.y, config.position.z);

            const frame = new THREE.Mesh(
                new THREE.BoxGeometry(1.5, 2.2, 0.1),
                new THREE.MeshStandardMaterial({ 
                    color: 0x1a1a1a,
                    metalness: 0.8,
                    roughness: 0.2 
                })
            );
            frame.castShadow = true;
            frame.receiveShadow = true;
            portalGroup.add(frame);

            const portalSurface = new THREE.Mesh(
                new THREE.PlaneGeometry(1.3, 2),
                new THREE.MeshBasicMaterial({ 
                    map: portalRenderTarget.texture,
                    side: THREE.DoubleSide
                })
            );
            portalSurface.position.z = 0.06;
            portalGroup.add(portalSurface);

            const glow = new THREE.Mesh(
                new THREE.PlaneGeometry(1.4, 2.1),
                new THREE.MeshBasicMaterial({ 
                    color: config.color,
                    transparent: true,
                    opacity: 0.2,
                    side: THREE.DoubleSide
                })
            );
            glow.position.z = 0.05;
            portalGroup.add(glow);

            scene.add(portalGroup);

            let splatViewer = null;
            try {
                console.log(`   üìÑ Loading splat...`);
                
                splatViewer = new GaussianSplats3D.Viewer({
                    threeScene: portalScene,
                    renderer: renderer,
                    camera: portalCamera,
                    selfDrivenMode: false,
                    useBuiltInControls: false,
                    showLoadingSpinner: false,
                    gpuAcceleratedSort: false,
                    integerBasedSort: false,
                    sharedMemoryForWorkers: false,
                    enableSplatSorting: true,
                    halfPrecisionCovariancesOnGPU: true,
                    dynamicScene: false,
                    webXRMode: GaussianSplats3D.WebXRMode.None,
                    renderMode: GaussianSplats3D.RenderMode.Always,
                    logLevel: GaussianSplats3D.LogLevel.Info
                });

                await splatViewer.init();
                console.log(`   ‚úÖ Viewer initialized`);

                await splatViewer.addSplatScene(config.splatFile, {
                    progressiveLoad: true,
                    splatAlphaRemovalThreshold: 5,
                    position: [0, 0, 0],
                    rotation: [1, 0, 0, 0],
                    scale: [config.scale, config.scale, config.scale]
                });

                console.log(`   ‚úÖ Portal ${index} splat loaded!`);

            } catch (error) {
                console.error(`   ‚ùå Portal ${index} failed:`, error);
            }

            portals.push({
                index,
                config,
                group: portalGroup,
                scene: portalScene,
                camera: portalCamera,
                renderTarget: portalRenderTarget,
                viewer: splatViewer,
                glow
            });

            return portals[portals.length - 1];
        }

        function updatePortalCamera(portal) {
            const portalPos = portal.group.position;
            const cameraToPortal = new THREE.Vector3().subVectors(camera.position, portalPos);
            const strength = portal.config.parallaxStrength;

            portal.camera.position.x = -cameraToPortal.x * strength;
            portal.camera.position.y = cameraToPortal.y * strength + 1;
            portal.camera.position.z = cameraToPortal.z * strength + 5;
            portal.camera.lookAt(0, 0, 0);
        }

        // ====== PORTAL INTERACTION ======
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        renderer.domElement.addEventListener('click', (event) => {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            if (isInSplatScene) {
                // Check for hotspot clicks only in portal 1
                if (activePortalIndex === 1) {
                    const hotspotObjects = [];
                    hotspots.forEach(hotspot => {
                        if (hotspot.sphere.visible) {
                            hotspotObjects.push(hotspot.sphere);
                        }
                    });

                    const intersects = raycaster.intersectObjects(hotspotObjects);
                    if (intersects.length > 0) {
                        const clickedHotspot = intersects[0].object;
                        const audioIndex = clickedHotspot.userData.audioIndex;
                        console.log(`üéØ Hotspot clicked: ${clickedHotspot.userData.name}`);
                        
                        initAudioContext();
                        playAudio(audioIndex);
                        
                        return;
                    }
                }
                
            } else {
                // Portal clicking logic
                portals.forEach((portal) => {
                    const intersects = raycaster.intersectObjects(portal.group.children, true);
                    if (intersects.length > 0) {
                        enterPortal(portal.index);
                    }
                });
            }
        });

        function updatePortalProximity() {
            if (isInSplatScene) return;

            let nearPortal = false;
            portals.forEach(portal => {
                const distance = camera.position.distanceTo(portal.group.position);
                if (distance < 6) nearPortal = true;
            });

            const prompt = document.getElementById('portal-prompt');
            if (nearPortal) {
                prompt.classList.add('show');
            } else {
                prompt.classList.remove('show');
            }
        }

        function enterPortal(portalIndex) {
            console.log(`üö™ Entering portal ${portalIndex}`);
            isInSplatScene = true;
            activePortalIndex = portalIndex;

            controls.enabled = false;
            splatControls.enabled = true;

            const activePortal = portals[portalIndex];
            if (activePortal && activePortal.viewer) {
                activePortal.viewer.camera = camera;
                console.log('‚úÖ Switched viewer to main camera');
            }

            camera.position.set(0, 2, 8);
            camera.lookAt(0, 0, 0);
            splatControls.target.set(0, 0, 0);
            splatControls.update();

            scene.background = new THREE.Color(0x1a1a2a);

            floor.visible = false;
            backWall.visible = false;
            leftWall.visible = false;
            rightWall.visible = false;
            cube.visible = false;
            portals.forEach(p => p.group.visible = false);
            spotlight1.visible = false;
            spotlight2.visible = false;
            spotlight3.visible = false;

            // Show hotspots only in portal 1
            if (portalIndex === 1) {
                console.log('üéØ Showing hotspots for middle portal');
                hotspots.forEach((hotspot, index) => {
                    hotspot.sphere.visible = true;
                    hotspot.glow.visible = true;
                    
                    if (activePortal && activePortal.scene) {
                        activePortal.scene.add(hotspot.sphere);
                        activePortal.scene.add(hotspot.glow);
                    }
                });
                document.getElementById('hotspot-info').classList.add('show');
                document.getElementById('hotspot-controls').classList.add('show');
            } else {
                hotspots.forEach(hotspot => {
                    hotspot.sphere.visible = false;
                    hotspot.glow.visible = false;
                    
                    if (hotspot.sphere.parent && hotspot.sphere.parent !== scene) {
                        hotspot.sphere.parent.remove(hotspot.sphere);
                    }
                    if (hotspot.glow.parent && hotspot.glow.parent !== scene) {
                        hotspot.glow.parent.remove(hotspot.glow);
                    }
                });
                document.getElementById('hotspot-info').classList.remove('show');
                document.getElementById('hotspot-controls').classList.remove('show');
            }

            // Show video controls and add video to portal 2 (third portal)
            if (portalIndex === 2) {
                console.log('üé¨ Showing video controls for portal 3');
                document.getElementById('video-controls').classList.add('show');
                
                // Initialize video sliders when controls are shown
                setTimeout(initializeVideoSliderControls, 100);
                
                if (isVideoActive && videoScreen) {
                    addVideoToPortal(2);
                }
            } else {
                document.getElementById('video-controls').classList.remove('show');
                removeVideoFromPortal();
            }

            let instructionText = `
                <h2>üåÄ Inside ${portals[portalIndex].config.name}</h2>
                <ul>
                    <li>Drag to rotate view</li>
                    <li>Scroll to zoom in/out</li>
                    <li>Explore the 3D space</li>`;
            
            if (portalIndex === 1) {
                instructionText += `<li>üéØ Look for glowing spheres to click!</li>`;
                instructionText += `<li>üîä Click to play/stop audio</li>`;
            }
            
            if (portalIndex === 2) {
                instructionText += `<li>üé¨ Use video controls to start feed!</li>`;
                instructionText += `<li>üì∫ Click video screen for interaction!</li>`;
            }
            
            instructionText += `<li>Press ESC to exit</li>
                </ul>
            `;

            document.getElementById('instructions').innerHTML = instructionText;
            document.getElementById('portal-prompt').classList.remove('show');
        }

        function exitPortal() {
            console.log('üö™ Exiting portal...');
            
            const activePortal = portals[activePortalIndex];
            if (activePortal && activePortal.viewer) {
                activePortal.viewer.camera = activePortal.camera;
                console.log('‚úÖ Restored portal camera');
            }

            // Clean up hotspots from portal scene
            if (activePortalIndex === 1 && activePortal && activePortal.scene) {
                for (let i = 0; i < currentlyPlayingAudio.length; i++) {
                    if (currentlyPlayingAudio[i]) {
                        try {
                            currentlyPlayingAudio[i].stop();
                        } catch (e) {
                            console.warn('Error stopping audio on exit:', e);
                        }
                        currentlyPlayingAudio[i] = null;
                        currentlyPlayingType[i] = null;
                    }
                }
                
                hotspots.forEach(hotspot => {
                    activePortal.scene.remove(hotspot.sphere);
                    activePortal.scene.remove(hotspot.glow);
                    scene.add(hotspot.sphere);
                    scene.add(hotspot.glow);
                    hotspot.sphere.visible = false;
                    hotspot.glow.visible = false;
                });
                console.log('üéØ Hotspots and audio cleaned up from portal scene');
            }

            // Clean up video from portal scene
            if (activePortalIndex === 2) {
                removeVideoFromPortal();
                console.log('üé¨ Video removed from portal scene');
            }

            isInSplatScene = false;
            activePortalIndex = -1;

            controls.enabled = true;
            splatControls.enabled = false;

            camera.position.set(0, 1.6, 8);
            controls.target.set(0, 0.8, -3);
            controls.update();

            scene.background = new THREE.Color(0x0a0a0a);

            floor.visible = true;
            backWall.visible = true;
            leftWall.visible = true;
            rightWall.visible = true;
            cube.visible = true;
            portals.forEach(p => p.group.visible = true);
            spotlight1.visible = true;
            spotlight2.visible = true;
            spotlight3.visible = true;

            document.getElementById('hotspot-info').classList.remove('show');
            document.getElementById('hotspot-controls').classList.remove('show');
            document.getElementById('video-controls').classList.remove('show');

            document.getElementById('instructions').innerHTML = `
                <h2>üåÄ Gallery Controls</h2>
                <ul>
                    <li>Left click + drag to orbit</li>
                    <li>Scroll to zoom in/out</li>
                    <li>Click any portal to enter</li>
                    <li>Each portal shows different view</li>
                </ul>
            `;
        }

        window.addEventListener('keydown', (event) => {
            if (event.key === 'Escape' && isInSplatScene) {
                exitPortal();
            }
        });

        // ====== ANIMATION LOOP ======
        function animate() {
            requestAnimationFrame(animate);

            if (isInSplatScene) {
                splatControls.update();

                const activePortal = portals[activePortalIndex];
                if (activePortal && activePortal.viewer) {
                    activePortal.viewer.update();
                    
                    renderer.setRenderTarget(null);
                    activePortal.viewer.render();
                }

                // Animate hotspots if visible
                if (activePortalIndex === 1) {
                    const time = Date.now() * 0.002;
                    hotspots.forEach((hotspot, index) => {
                        if (hotspot.sphere.visible && hotspot.sphere.parent === activePortal.scene) {
                            hotspot.sphere.material.opacity = 0.7 + Math.sin(time * 3 + index * 2) * 0.3;
                            hotspot.glow.material.opacity = 0.4 + Math.sin(time * 2 + index * 2) * 0.2;
                            
                            const baseY = hotspotPositions[index].y;
                            const floatOffset = Math.sin(time * 1.5 + index * 3) * 0.2;
                            hotspot.sphere.position.y = baseY + floatOffset;
                            hotspot.glow.position.copy(hotspot.sphere.position);
                        }
                    });
                }

                // Animate video screen if visible
                if (activePortalIndex === 2 && videoScreen && videoScreen.visible && isVideoActive) {
                    // No automatic floating animation - user controls position with sliders
                    // Just update video texture
                    if (videoTexture && videoElement) {
                        // Check if video is actually playing
                        if (videoElement.readyState >= videoElement.HAVE_CURRENT_DATA && 
                            !videoElement.paused && 
                            videoElement.currentTime > 0) {
                            videoTexture.needsUpdate = true;
                            
                            // Debug log occasionally
                            const time = Date.now() * 0.001;
                            if (Math.floor(time) % 5 === 0 && Math.floor(time * 10) % 10 === 0) {
                                console.log('üé¨ Video texture updated:', {
                                    currentTime: videoElement.currentTime.toFixed(1),
                                    videoSize: `${videoElement.videoWidth}x${videoElement.videoHeight}`,
                                    position: `(${videoScreen.position.x.toFixed(1)}, ${videoScreen.position.y.toFixed(1)}, ${videoScreen.position.z.toFixed(1)})`,
                                    readyState: videoElement.readyState,
                                    paused: videoElement.paused
                                });
                            }
                        } else {
                            // Video not ready - try to play it
                            if (videoElement.paused && videoElement.readyState >= videoElement.HAVE_METADATA) {
                                videoElement.play().catch(e => {
                                    console.warn('Video autoplay failed:', e);
                                });
                            }
                        }
                    }
                }
            } else {
                controls.update();
                updatePortalProximity();

                cube.rotation.x += 0.005;
                cube.rotation.y += 0.005;

                portals.forEach(portal => {
                    updatePortalCamera(portal);

                    if (portal.viewer) {
                        portal.viewer.update();
                        
                        renderer.setRenderTarget(portal.renderTarget);
                        portal.viewer.render();
                        renderer.setRenderTarget(null);
                    }

                    const time = Date.now() * 0.001;
                    portal.glow.material.opacity = 0.2 + Math.sin(time * 2 + portal.index) * 0.1;
                });

                renderer.render(scene, camera);
            }
        }

        // ====== INITIALIZATION ======
        async function init() {
            document.getElementById('loading-text').textContent = 'Creating portal gallery with video support...';

            createHotspots();

            for (let i = 0; i < PORTAL_CONFIGS.length; i++) {
                document.getElementById('loading-text').textContent = `Loading portal ${i + 1}/${PORTAL_CONFIGS.length}...`;
                await createPortal(PORTAL_CONFIGS[i], i);
            }

            document.getElementById('portal-count').textContent = portals.length;
            document.getElementById('loading').style.display = 'none';
            document.getElementById('instructions').style.display = 'block';
            document.getElementById('gallery-info').style.display = 'block';
            document.getElementById('file-info').style.display = 'block';

            animate();
            console.log('‚úÖ Portal gallery with video and hotspots ready!');
        }

        // ====== WINDOW RESIZE ======
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // ====== START ======
        init().catch(err => {
            console.error('Init failed:', err);
            document.getElementById('loading-text').textContent = 'Error: ' + err.message;
        });
    </script>
</body>
</html>