<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gaussian Splat Gallery + Video Feed</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            overflow: hidden;
            background: #000;
        }
        #canvas-container {
            width: 100vw;
            height: 100vh;
        }
        #instructions {
            position: fixed;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            font-size: 14px;
            max-width: 300px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(74, 158, 255, 0.3);
            z-index: 100;
        }
        #instructions h2 {
            margin: 0 0 15px 0;
            font-size: 18px;
            color: #4a9eff;
        }
        #instructions ul {
            list-style: none;
            padding: 0;
        }
        #instructions li {
            margin: 8px 0;
            padding-left: 20px;
            position: relative;
        }
        #instructions li:before {
            content: "‚Üí";
            position: absolute;
            left: 0;
            color: #4a9eff;
        }
        #loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 20px;
            text-align: center;
            background: rgba(0, 0, 0, 0.8);
            padding: 30px;
            border-radius: 10px;
            min-width: 300px;
            z-index: 1000;
        }
        .spinner {
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-top: 3px solid #4a9eff;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        #portal-prompt {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            background: rgba(74, 158, 255, 0.9);
            padding: 20px 40px;
            border-radius: 10px;
            font-size: 18px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 200;
        }
        #portal-prompt.show {
            opacity: 1;
        }
        #file-info {
            position: fixed;
            bottom: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 8px;
            font-size: 12px;
            font-family: monospace;
            z-index: 100;
        }
        #gallery-info {
            position: fixed;
            top: 20px;
            right: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            font-size: 14px;
            max-width: 300px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(74, 158, 255, 0.3);
            z-index: 100;
        }
        #gallery-info h2 {
            margin: 0 0 15px 0;
            font-size: 18px;
            color: #4a9eff;
        }
        #hotspot-info {
            position: fixed;
            bottom: 20px;
            right: 20px;
            color: white;
            background: rgba(255, 102, 0, 0.9);
            padding: 15px;
            border-radius: 8px;
            font-size: 14px;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 100;
        }
        #hotspot-info.show {
            opacity: 1;
        }
        #hotspot-controls {
            position: fixed;
            bottom: 20px;
            right: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.9);
            padding: 20px;
            border-radius: 10px;
            font-size: 12px;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 100;
            max-width: 300px;
            border: 1px solid rgba(74, 158, 255, 0.3);
        }
        #hotspot-controls.show {
            opacity: 1;
        }
        #hotspot-controls h3 {
            margin: 0 0 15px 0;
            font-size: 14px;
            color: #4a9eff;
        }
        .hotspot-slider-group {
            margin-bottom: 15px;
            padding: 10px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 5px;
        }
        .hotspot-slider-group h4 {
            margin: 0 0 10px 0;
            font-size: 12px;
        }
        .cyan-group h4 {
            color: #00ffff;
        }
        .orange-group h4 {
            color: #ff6600;
        }
        .slider-row {
            display: flex;
            align-items: center;
            margin: 5px 0;
        }
        .slider-row label {
            width: 15px;
            font-weight: bold;
        }
        .slider-row input[type="range"] {
            flex: 1;
            margin: 0 8px;
            height: 20px;
        }
        .slider-row span {
            width: 40px;
            text-align: right;
            font-family: monospace;
            font-size: 11px;
        }
        .reset-btn {
            background: rgba(74, 158, 255, 0.8);
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 10px;
            margin-top: 5px;
        }
        .reset-btn:hover {
            background: rgba(74, 158, 255, 1);
        }
        
        /* VIDEO CONTROLS */
        #video-controls {
            position: fixed;
            bottom: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.9);
            padding: 20px;
            border-radius: 10px;
            font-size: 12px;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 100;
            max-width: 350px;
            border: 1px solid rgba(255, 0, 255, 0.5);
            max-height: 80vh;
            overflow-y: auto;
        }
        #video-controls.show {
            opacity: 1;
        }
        #video-controls h3 {
            margin: 0 0 15px 0;
            font-size: 14px;
            color: #ff00ff;
        }
        .video-button {
            background: rgba(255, 0, 255, 0.7);
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
            margin: 5px 5px 5px 0;
        }
        .video-button:hover {
            background: rgba(255, 0, 255, 1);
        }
        .video-button:disabled {
            background: rgba(100, 100, 100, 0.5);
            cursor: not-allowed;
        }
        
        /* Hidden video element for texture source */
        #hidden-video {
            display: none;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    
    <!-- Hidden video element for texture source -->
    <video id="hidden-video" muted playsinline crossorigin="anonymous"></video>
    
    <div id="loading">
        <div class="spinner"></div>
        <div id="loading-text">Loading Gallery...</div>
    </div>
    
    <div id="instructions" style="display: none;">
        <h2>üåÄ Gallery Controls</h2>
        <ul>
            <li>Left click + drag to orbit</li>
            <li>Scroll to zoom in/out</li>
            <li>Click any portal to enter</li>
            <li>Each portal shows different view</li>
        </ul>
    </div>
    
    <div id="gallery-info" style="display: none;">
        <h2>üìä Portal Description</h2>
        <div style="font-size: 12px; line-height: 1.8;">
            <div style="color: #4a9eff;">‚óè Portal 1: first test guass</div>
            <div style="color: #ff6b6b;">‚óè Portal 2: Sony A7S & SuperPoint SuperGlue method Nov 2nd (üéØ Interactive Hotspots)</div>
            <div style="color: #51cf66;">‚óè Portal 3: Reference + üé¨ VIDEO FEED!</div>
        </div>
    </div>
    
    <div id="file-info" style="display: none;">
        <div>üìÅ Gallery loaded successfully</div>
        <div>üé® <span id="portal-count">0</span> Portals Active</div>
        <div>üé¨ Video Feed Ready</div>
    </div>

    <div id="portal-prompt">
        Click portal to enter the 3D scene!
    </div>

    <div id="hotspot-info">
        üéØ Click glowing spheres! (Cyan=info.mp3, Orange=bass.mp3) Click again to stop!
    </div>

    <div id="hotspot-controls">
        <h3>üéØ Hotspot Position Controls</h3>
        
        <div class="hotspot-slider-group cyan-group">
            <h4>Cyan Hotspot (info.mp3)</h4>
            <div class="slider-row">
                <label>X:</label>
                <input type="range" id="cyan-x" min="-12" max="12" step="0.1" value="7">
                <span id="cyan-x-val">7.0</span>
            </div>
            <div class="slider-row">
                <label>Y:</label>
                <input type="range" id="cyan-y" min="-4" max="4" step="0.1" value="-2">
                <span id="cyan-y-val">-2.0</span>
            </div>
            <div class="slider-row">
                <label>Z:</label>
                <input type="range" id="cyan-z" min="-4" max="10" step="0.1" value="-2">
                <span id="cyan-z-val">-2.0</span>
            </div>
            <button class="reset-btn" onclick="resetCyanPosition()">Reset</button>
        </div>

        <div class="hotspot-slider-group orange-group">
            <h4>Orange Hotspot (bass.mp3)</h4>
            <div class="slider-row">
                <label>X:</label>
                <input type="range" id="orange-x" min="-12" max="12" step="0.1" value="-2.5">
                <span id="orange-x-val">-2.5</span>
            </div>
            <div class="slider-row">
                <label>Y:</label>
                <input type="range" id="orange-y" min="-4" max="4" step="0.1" value="-3">
                <span id="orange-y-val">-3.0</span>
            </div>
            <div class="slider-row">
                <label>Z:</label>
                <input type="range" id="orange-z" min="-4" max="10" step="0.1" value="8.1">
                <span id="orange-z-val">8.1</span>
            </div>
            <button class="reset-btn" onclick="resetOrangePosition()">Reset</button>
        </div>
        
        <div style="margin-top: 15px; font-size: 10px; color: #ccc;">
            Move sliders to position hotspots! Range: X/Y ¬±12/¬±4, Z -4‚Üí10
        </div>
    </div>

    <!-- VIDEO CONTROLS -->
    <div id="video-controls">
        <h3>üé¨ Video Feed Controls</h3>
        <div style="margin-bottom: 15px;">
            <label style="display: block; margin-bottom: 5px; font-size: 11px; color: #ccc;">Video URL:</label>
            <input type="text" id="video-url-input" placeholder="Enter video URL (mp4, webm, etc.)" 
                   style="width: 100%; padding: 5px; border-radius: 3px; border: 1px solid #444; background: #222; color: white; font-size: 11px;">
            <button class="video-button" style="margin-top: 5px; font-size: 10px;" onclick="loadVideoFromURL()">üîó Load URL</button>
        </div>
        <div>
            <button class="video-button" id="webcam-btn" onclick="startWebcam()">üì∑ Start Webcam</button>
            <button class="video-button" id="test-video-btn" onclick="loadTestVideo()">üé• Test Video</button>
        </div>
        <div style="margin-top: 10px;">
            <button class="video-button" id="stop-video-btn" onclick="stopVideo()" disabled>‚èπÔ∏è Stop Video</button>
        </div>
        
        <!-- Video Position Controls -->
        <div style="margin-top: 15px; padding: 10px; border: 1px solid rgba(255, 0, 255, 0.3); border-radius: 5px;">
            <h4 style="margin: 0 0 10px 0; font-size: 12px; color: #ff00ff;">üì∫ Video Screen Position</h4>
            <div class="slider-row">
                <label style="width: 15px; font-weight: bold; color: #ff00ff;">X:</label>
                <input type="range" id="video-x" min="-8" max="8" step="0.1" value="0">
                <span id="video-x-val" style="width: 40px; text-align: right; font-family: monospace; font-size: 11px;">0.0</span>
            </div>
            <div class="slider-row">
                <label style="width: 15px; font-weight: bold; color: #ff00ff;">Y:</label>
                <input type="range" id="video-y" min="-4" max="6" step="0.1" value="1">
                <span id="video-y-val" style="width: 40px; text-align: right; font-family: monospace; font-size: 11px;">1.0</span>
            </div>
            <div class="slider-row">
                <label style="width: 15px; font-weight: bold; color: #ff00ff;">Z:</label>
                <input type="range" id="video-z" min="-20" max="20" step="0.1" value="2">
                <span id="video-z-val" style="width: 40px; text-align: right; font-family: monospace; font-size: 11px;">2.0</span>
            </div>
            <div class="slider-row">
                <label style="width: 15px; font-weight: bold; color: #ff00ff;">S:</label>
                <input type="range" id="video-scale" min="0.1" max="5.0" step="0.1" value="1.0">
                <span id="video-scale-val" style="width: 40px; text-align: right; font-family: monospace; font-size: 11px;">1.0</span>
            </div>
        </div>
        
        <!-- Video Rotation Controls -->
        <div style="margin-top: 15px; padding: 10px; border: 1px solid rgba(255, 0, 255, 0.3); border-radius: 5px;">
            <h4 style="margin: 0 0 10px 0; font-size: 12px; color: #ff00ff;">üîÑ Video Screen Rotation</h4>
            <div class="slider-row">
                <label style="width: 15px; font-weight: bold; color: #ff00ff;">X:</label>
                <input type="range" id="video-rot-x" min="-180" max="180" step="1" value="0">
                <span id="video-rot-x-val" style="width: 40px; text-align: right; font-family: monospace; font-size: 11px;">0¬∞</span>
            </div>
            <div class="slider-row">
                <label style="width: 15px; font-weight: bold; color: #ff00ff;">Y:</label>
                <input type="range" id="video-rot-y" min="-180" max="180" step="1" value="0">
                <span id="video-rot-y-val" style="width: 40px; text-align: right; font-family: monospace; font-size: 11px;">0¬∞</span>
            </div>
            <div class="slider-row">
                <label style="width: 15px; font-weight: bold; color: #ff00ff;">Z:</label>
                <input type="range" id="video-rot-z" min="-180" max="180" step="1" value="0">
                <span id="video-rot-z-val" style="width: 40px; text-align: right; font-family: monospace; font-size: 11px;">0¬∞</span>
            </div>
            <button class="reset-btn" style="background: rgba(255, 0, 255, 0.7);" onclick="resetVideoTransform()">Reset All Transform</button>
        </div>
        
        <div style="margin-top: 15px; font-size: 9px; color: #ccc; line-height: 1.3;">
            Video appears as floating screen in Portal 3!<br>
            <strong>Position:</strong> X,Y,Z coordinates<br>
            <strong>Scale:</strong> 0.1x - 5.0x<br>
            <strong>Rotation:</strong> X,Y,Z angles (-180¬∞ to +180¬∞)<br>
            <strong>Example URLs:</strong><br>
            ‚Ä¢ https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4<br>
            ‚Ä¢ https://sample-videos.com/zip/10/mp4/SampleVideo_1280x720_1mb.mp4<br>
            ‚Ä¢ Local: ./myvideo.mp4
        </div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import * as GaussianSplats3D from 'https://cdn.jsdelivr.net/npm/@mkkellogg/gaussian-splats-3d@latest/build/gaussian-splats-3d.module.min.js';

        // ====== VIDEO SYSTEM ======
        // Hidden video element that serves as texture source
        let videoElement = document.getElementById('hidden-video');
        let videoTexture = null;          // Three.js video texture
        let videoScreen = null;            // The mesh displaying the video
        let videoMaterial = null;          // Material for video mesh
        let isVideoActive = false;         // Track if video is currently playing

        // Video transformation properties (position, scale, rotation)
        let videoPosition = { x: 0, y: 1, z: 2 }; // Default 3D position
        let videoScale = 1.0;                      // Default scale multiplier
        let videoRotation = { x: 0, y: 0, z: 0 }; // Default rotation in radians

        // ====== PORTAL CONFIGURATION ======
        // Define the three portal scenes with their properties
        const PORTAL_CONFIGS = [
            {
                name: "First Guassian Test iPhone and Record3D",
                splatFile: "https://huggingface.co/mysterytreebeast/gaussian-splat-models/resolve/main/frontroom_1506.ply",
                position: { x: -5, y: 0.5, z: -5 },
                color: 0x4a9eff,
                parallaxStrength: 0.5,  // How much camera movement affects portal view
                scale: 5
            },
            {
                name: "Sony A7 photoset morning",
                splatFile: "https://huggingface.co/mysterytreebeast/gaussian-splat-models/resolve/main/02112025Morning.ply",
                position: { x: 0, y: 0.5, z: -6 },
                color: 0xff6b6b,
                parallaxStrength: 0.3,
                scale: 5
            },
            {
                name: "Reference + Video Feed",
                splatFile: "https://huggingface.co/mysterytreebeast/gaussian-splat-models/resolve/main/InteriorDesign.ply",
                position: { x: 5, y: 0.5, z: -5 },
                color: 0x51cf66,
                parallaxStrength: 0.1,
                scale: 5
            }
        ];

        // ====== MAIN SCENE SETUP ======
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0a0a);

        // Setup main camera with 50¬∞ FOV
        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 1.6, 8);

        // Setup WebGL renderer with shadows
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // Setup orbit controls for main gallery view
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 3;
        controls.maxDistance = 20;
        controls.maxPolarAngle = Math.PI / 2;
        controls.target.set(0, 0.8, -3);

        // ====== VIDEO FUNCTIONS ======
        /**
         * Creates a 3D plane mesh to display video content
         * Sets up video texture and material with proper settings
         */
        function createVideoScreen() {
            console.log('üé¨ Creating video screen...');
            console.log('Video element state:', {
                videoWidth: videoElement.videoWidth,
                videoHeight: videoElement.videoHeight,
                readyState: videoElement.readyState,
                paused: videoElement.paused,
                currentTime: videoElement.currentTime
            });
            
            // Create video texture with proper settings for dynamic updates
            videoTexture = new THREE.VideoTexture(videoElement);
            videoTexture.minFilter = THREE.LinearFilter;
            videoTexture.magFilter = THREE.LinearFilter;
            videoTexture.format = THREE.RGBAFormat;
            videoTexture.generateMipmaps = false;
            videoTexture.wrapS = THREE.ClampToEdgeWrapping;
            videoTexture.wrapT = THREE.ClampToEdgeWrapping;
            
            // Create material with video texture
            videoMaterial = new THREE.MeshBasicMaterial({ 
                map: videoTexture,
                side: THREE.DoubleSide,  // Visible from both sides
                transparent: false
            });
            
            // Create 16:9 aspect ratio plane for video display
            const screenGeometry = new THREE.PlaneGeometry(4, 2.25);
            videoScreen = new THREE.Mesh(screenGeometry, videoMaterial);
            
            // Apply initial transformation
            videoScreen.position.set(videoPosition.x, videoPosition.y, videoPosition.z);
            videoScreen.scale.set(videoScale, videoScale, videoScale);
            videoScreen.rotation.set(
                videoRotation.x * Math.PI / 180,
                videoRotation.y * Math.PI / 180,
                videoRotation.z * Math.PI / 180
            );
            videoScreen.userData = { isVideoScreen: true };
            
            console.log('‚úÖ Video screen created at position:', videoScreen.position, 'with scale:', videoScale);
            return videoScreen;
        }

        /**
         * Adds video screen to a specific portal's scene
         * @param {number} portalIndex - Index of portal to add video to (default: 2)
         */
        function addVideoToPortal(portalIndex = 2) {
            const portal = portals[portalIndex];
            if (portal && portal.scene && videoScreen) {
                // Remove from any previous parent first
                if (videoScreen.parent) {
                    videoScreen.parent.remove(videoScreen);
                }
                
                // Add to portal scene
                portal.scene.add(videoScreen);
                console.log(`üé¨ Video screen added to portal ${portalIndex}`);
            }
        }

        /**
         * Removes video screen from its current parent portal
         */
        function removeVideoFromPortal() {
            if (videoScreen && videoScreen.parent) {
                videoScreen.parent.remove(videoScreen);
                console.log('üé¨ Video screen removed from portal');
            }
        }

        // ====== VIDEO CONTROL FUNCTIONS ======
        // Made global for HTML button onclick handlers

        /**
         * Loads video from user-provided URL
         * Handles CORS and autoplay policies
         */
        window.loadVideoFromURL = function() {
            const urlInput = document.getElementById('video-url-input');
            const videoUrl = urlInput.value.trim();
            
            if (!videoUrl) {
                alert('Please enter a video URL');
                return;
            }
            
            try {
                console.log('üîó Loading video from URL:', videoUrl);
                
                // Stop any existing video stream first
                if (videoElement.srcObject) {
                    const stream = videoElement.srcObject;
                    const tracks = stream.getTracks();
                    tracks.forEach(track => track.stop());
                    videoElement.srcObject = null;
                }
                
                // Set video source to URL
                videoElement.src = videoUrl;
                videoElement.crossOrigin = "anonymous"; // For CORS
                videoElement.loop = true;
                videoElement.muted = true; // Required for autoplay
                videoElement.play();
                
                // Create video screen if it doesn't exist
                if (!videoScreen) {
                    createVideoScreen();
                }
                
                isVideoActive = true;
                
                // Update button states
                document.getElementById('webcam-btn').disabled = true;
                document.getElementById('test-video-btn').disabled = true;
                document.getElementById('stop-video-btn').disabled = false;
                
                console.log('‚úÖ Video URL loaded successfully');
                
                // Add to portal if currently viewing it
                if (activePortalIndex === 2) {
                    addVideoToPortal(2);
                }
                
            } catch (error) {
                console.error('‚ùå Video URL loading failed:', error);
                alert(`Failed to load video: ${error.message}`);
            }
        };

        /**
         * Starts webcam feed as video source
         * Requests camera permissions and handles errors
         */
        window.startWebcam = async function() {
            try {
                console.log('üì∑ Starting webcam...');
                
                // Stop any existing video first
                if (videoElement.srcObject) {
                    const stream = videoElement.srcObject;
                    const tracks = stream.getTracks();
                    tracks.forEach(track => track.stop());
                }
                
                // Request webcam access with ideal resolution
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { 
                        width: { ideal: 1280 }, 
                        height: { ideal: 720 },
                        facingMode: 'user'  // Front-facing camera
                    },
                    audio: false 
                });
                
                console.log('üìπ Webcam stream acquired:', stream);
                console.log('Video tracks:', stream.getVideoTracks());
                
                // Configure video element for webcam
                videoElement.srcObject = stream;
                videoElement.muted = true;
                videoElement.autoplay = true;
                videoElement.playsInline = true;
                
                // Wait for video metadata to load
                videoElement.onloadedmetadata = () => {
                    console.log('üì∫ Webcam metadata loaded:', {
                        videoWidth: videoElement.videoWidth,
                        videoHeight: videoElement.videoHeight
                    });
                    
                    videoElement.play().then(() => {
                        console.log('‚úÖ Webcam playing successfully');
                    }).catch(err => {
                        console.error('‚ùå Webcam play failed:', err);
                    });
                };
                
                // Create video screen if needed
                if (!videoScreen) {
                    createVideoScreen();
                }
                
                isVideoActive = true;
                
                // Update button states
                document.getElementById('webcam-btn').disabled = true;
                document.getElementById('test-video-btn').disabled = true;
                document.getElementById('stop-video-btn').disabled = false;
                
                console.log('‚úÖ Webcam started successfully');
                
                // Add to portal if viewing it
                if (activePortalIndex === 2) {
                    addVideoToPortal(2);
                }
                
            } catch (error) {
                console.error('‚ùå Webcam access failed:', error);
                let errorMsg = 'Could not access webcam.';
                
                // Provide specific error messages
                if (error.name === 'NotAllowedError') {
                    errorMsg += ' Please check camera permissions.';
                } else if (error.name === 'NotFoundError') {
                    errorMsg += ' No camera found.';
                } else if (error.name === 'OverconstrainedError') {
                    errorMsg += ' Camera constraints not supported.';
                } else {
                    errorMsg += ` Error: ${error.message}`;
                }
                
                alert(errorMsg);
            }
        };

        /**
         * Loads a procedurally generated test video
         * Creates animated color bars using canvas
         */
        window.loadTestVideo = function() {
            try {
                console.log('üé• Loading test video...');
                
                // Stop any existing video
                if (videoElement.srcObject) {
                    const stream = videoElement.srcObject;
                    const tracks = stream.getTracks();
                    tracks.forEach(track => track.stop());
                    videoElement.srcObject = null;
                }
                
                // Create canvas for test pattern
                const canvas = document.createElement('canvas');
                canvas.width = 640;
                canvas.height = 360;
                const ctx = canvas.getContext('2d');
                
                console.log('üì∫ Canvas created:', canvas.width + 'x' + canvas.height);
                
                /**
                 * Draws animated color bars with time and frame info
                 * Called repeatedly via requestAnimationFrame
                 */
                function drawColorBars() {
                    const time = Date.now() * 0.001;
                    
                    // Clear canvas with black background
                    ctx.fillStyle = '#000000';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw animated rainbow color bars
                    const colors = ['#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff', '#00ffff', '#ffffff'];
                    
                    for (let i = 0; i < colors.length; i++) {
                        ctx.fillStyle = colors[i];
                        const barWidth = canvas.width / colors.length;
                        const barHeight = canvas.height * 0.6;
                        const yOffset = canvas.height * 0.2;
                        const animOffset = Math.sin(time * 2 + i * 0.5) * 20;
                        
                        ctx.fillRect(i * barWidth, yOffset + animOffset, barWidth - 2, barHeight);
                    }
                    
                    // Add text overlays for debugging
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 32px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('TEST VIDEO', canvas.width/2, 40);
                    
                    ctx.font = 'bold 24px Arial';
                    ctx.fillText(`Time: ${time.toFixed(1)}s`, canvas.width/2, canvas.height - 20);
                    
                    ctx.font = '16px Arial';
                    ctx.fillText(`Frame: ${Math.floor(time * 30)}`, canvas.width/2, canvas.height - 50);
                    
                    requestAnimationFrame(drawColorBars);
                }
                
                drawColorBars();
                
                // Create video stream from canvas at 30fps
                const stream = canvas.captureStream(30);
                console.log('üé¨ Canvas stream created:', stream);
                console.log('Stream tracks:', stream.getTracks());
                
                // Configure video element
                videoElement.srcObject = stream;
                videoElement.muted = true;
                videoElement.loop = true;
                videoElement.autoplay = true;
                videoElement.playsInline = true;
                
                // Wait for metadata then play
                videoElement.onloadedmetadata = () => {
                    console.log('üì∫ Video metadata loaded:', {
                        videoWidth: videoElement.videoWidth,
                        videoHeight: videoElement.videoHeight,
                        duration: videoElement.duration
                    });
                    videoElement.play().then(() => {
                        console.log('‚úÖ Video playing successfully');
                    }).catch(err => {
                        console.error('‚ùå Video play failed:', err);
                    });
                };
                
                // Create video screen if needed
                if (!videoScreen) {
                    createVideoScreen();
                }
                
                isVideoActive = true;
                
                // Update button states
                document.getElementById('webcam-btn').disabled = true;
                document.getElementById('test-video-btn').disabled = true;
                document.getElementById('stop-video-btn').disabled = false;
                
                console.log('‚úÖ Test video setup complete');
                
                // Add to portal if viewing it
                if (activePortalIndex === 2) {
                    addVideoToPortal(2);
                }
                
            } catch (error) {
                console.error('‚ùå Test video creation failed:', error);
                alert(`Test video failed: ${error.message}`);
            }
        };

        /**
         * Stops all video playback and cleans up resources
         */
        window.stopVideo = function() {
            console.log('‚èπÔ∏è Stopping video...');
            
            // Stop media stream tracks
            if (videoElement.srcObject) {
                const stream = videoElement.srcObject;
                const tracks = stream.getTracks();
                tracks.forEach(track => track.stop());
                videoElement.srcObject = null;
            }
            
            removeVideoFromPortal();
            isVideoActive = false;
            
            // Update button states
            document.getElementById('webcam-btn').disabled = false;
            document.getElementById('test-video-btn').disabled = false;
            document.getElementById('stop-video-btn').disabled = true;
            
            console.log('‚úÖ Video stopped');
        };

        // ====== LIGHTING SETUP ======
        // Add ambient light for general scene illumination
        scene.add(new THREE.AmbientLight(0x111111, 0.2));

        // Spotlight for left portal (blue tint)
        const spotlight1 = new THREE.SpotLight(0x4a9eff, 10);
        spotlight1.position.set(-5, 8, -3);
        spotlight1.angle = Math.PI / 5;
        spotlight1.penumbra = 0.6;
        spotlight1.decay = 1.5;
        spotlight1.distance = 20;
        spotlight1.castShadow = true;
        spotlight1.target.position.set(-5, 0.5, -5);
        scene.add(spotlight1);
        scene.add(spotlight1.target);

        // Spotlight for middle portal (red tint)
        const spotlight2 = new THREE.SpotLight(0xff3333, 10);
        spotlight2.position.set(0, 8, -4);
        spotlight2.angle = Math.PI / 5;
        spotlight2.penumbra = 0.6;
        spotlight2.decay = 1.5;
        spotlight2.distance = 20;
        spotlight2.castShadow = true;
        spotlight2.target.position.set(0, 0.5, -6);
        scene.add(spotlight2);
        scene.add(spotlight2.target);

        // Spotlight for right portal (light blue tint)
        const spotlight3 = new THREE.SpotLight(0xaaccff, 10);
        spotlight3.position.set(5, 8, -3);
        spotlight3.angle = Math.PI / 5;
        spotlight3.penumbra = 0.7;
        spotlight3.decay = 1.5;
        spotlight3.distance = 20;
        spotlight3.castShadow = true;
        spotlight3.target.position.set(5, 0.5, -5);
        scene.add(spotlight3);
        scene.add(spotlight3.target);

        // ====== ROOM GEOMETRY ======
        // Create floor plane
        const floor = new THREE.Mesh(
            new THREE.PlaneGeometry(30, 30),
            new THREE.MeshStandardMaterial({ color: 0x1fffff })
        );
        floor.rotation.x = -Math.PI / 2;
        floor.position.y = -1;
        floor.receiveShadow = true;
        scene.add(floor);

        // Create room walls
        const wallMat = new THREE.MeshStandardMaterial({ 
            color: 0xffffff, 
            side: THREE.DoubleSide 
        });
        
        // Back wall
        const backWall = new THREE.Mesh(new THREE.PlaneGeometry(30, 10), wallMat);
        backWall.position.set(0, 4, -8);
        backWall.receiveShadow = true;
        scene.add(backWall);

        // Left wall
        const leftWall = new THREE.Mesh(new THREE.PlaneGeometry(20, 10), wallMat);
        leftWall.position.set(-10, 4, 0);
        leftWall.rotation.y = Math.PI / 2;
        leftWall.receiveShadow = true;
        scene.add(leftWall);

        // Right wall
        const rightWall = new THREE.Mesh(new THREE.PlaneGeometry(20, 10), wallMat);
        rightWall.position.set(10, 4, 0);
        rightWall.rotation.y = -Math.PI / 2;
        rightWall.receiveShadow = true;
        scene.add(rightWall);

        // Add decorative cube for reference
        const cube = new THREE.Mesh(
            new THREE.BoxGeometry(0.8, 0.8, 0.8),
            new THREE.MeshStandardMaterial({ color: 0xFFFF00 })
        );
        cube.position.set(-1, 0, -5);
        cube.castShadow = true;
        cube.receiveShadow = true;
        scene.add(cube);

        // ====== PORTAL SYSTEM ======
        const portals = [];              // Array of portal objects
        let activePortalIndex = -1;      // Currently active portal (-1 = none)
        let isInSplatScene = false;      // Whether user is inside a portal
        let splatControls = null;        // OrbitControls for inside portal view

        // ====== HOTSPOT SYSTEM ======
        // Interactive audio hotspots for portal 2
        const hotspots = [];
        let audioContext = null;                    // Web Audio API context
        let currentlyPlayingAudio = [null, null];   // Currently playing audio sources
        let currentlyPlayingType = [null, null];    // Type of audio playing (file/synthetic)
        
        // Initial hotspot positions (can be adjusted with sliders)
        let hotspotPositions = [
            { x: 7, y: -2, z: -2 },      // Cyan hotspot
            { x: 2.8, y: -3, z: 6.8 }    // Orange hotspot
        ];
        
        const AUDIO_FILES = ['info.mp3', 'bass.mp3'];

        // ====== AUDIO FUNCTIONS ======
        /**
         * Creates a simple synthetic audio tone as fallback
         * @param {number} audioIndex - Index of hotspot (0 or 1)
         * @returns {OscillatorNode} Audio oscillator or null
         */
        function createSyntheticAudio(audioIndex) {
            if (!audioContext) return null;
            
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            // Different frequencies for each hotspot
            const frequencies = [800, 400];
            const frequency = frequencies[audioIndex] || 440;
            
            oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
            oscillator.type = 'sine';
            
            // Fade in/out envelope
            gainNode.gain.setValueAtTime(0, audioContext.currentTime);
            gainNode.gain.linearRampToValueAtTime(0.3, audioContext.currentTime + 0.1);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.8);
            
            oscillator.start();
            oscillator.stop(audioContext.currentTime + 0.8);
            
            return oscillator;
        }

        /**
         * Initializes Web Audio API context
         * Required for playing audio on the web
         */
        function initAudioContext() {
            if (!audioContext) {
                try {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                } catch (e) {
                    console.warn('AudioContext not supported, falling back to HTML5 Audio');
                }
            }
        }

        /**
         * Plays or stops audio for a hotspot
         * Tries to load external file, falls back to synthetic audio
         * @param {number} audioIndex - Index of hotspot (0 or 1)
         */
        async function playAudio(audioIndex) {
            console.log(`üîä Audio control for hotspot ${audioIndex + 1}`);
            
            // If already playing, stop it
            if (currentlyPlayingAudio[audioIndex]) {
                stopAudio(audioIndex);
                return;
            }
            
            try {
                initAudioContext();
                
                // Resume audio context if suspended (mobile requirement)
                if (audioContext && audioContext.state === 'suspended') {
                    await audioContext.resume();
                }

                const audioUrl = AUDIO_FILES[audioIndex];
                
                // Try to load external audio file
                if (audioUrl) {
                    try {
                        const response = await fetch(audioUrl);
                        const arrayBuffer = await response.arrayBuffer();
                        const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                        
                        const source = audioContext.createBufferSource();
                        source.buffer = audioBuffer;
                        source.connect(audioContext.destination);
                        
                        currentlyPlayingAudio[audioIndex] = source;
                        currentlyPlayingType[audioIndex] = 'file';
                        
                        source.onended = () => {
                            currentlyPlayingAudio[audioIndex] = null;
                            currentlyPlayingType[audioIndex] = null;
                        };
                        
                        source.start();
                        console.log('‚úÖ External audio file playing');
                        
                        showAudioFeedback(audioIndex, 'file');
                        return;
                    } catch (fetchError) {
                        console.warn('External audio failed, using synthetic audio:', fetchError);
                    }
                }
                
                // Fallback to synthetic audio
                if (audioContext) {
                    const oscillator = createSyntheticAudio(audioIndex);
                    if (oscillator) {
                        currentlyPlayingAudio[audioIndex] = oscillator;
                        currentlyPlayingType[audioIndex] = 'synthetic';
                        
                        oscillator.onended = () => {
                            currentlyPlayingAudio[audioIndex] = null;
                            currentlyPlayingType[audioIndex] = null;
                        };
                        
                        console.log('‚úÖ Synthetic audio playing');
                        showAudioFeedback(audioIndex, 'synthetic');
                    }
                } else {
                    throw new Error('No AudioContext available');
                }
                
            } catch (error) {
                console.error('All audio methods failed:', error);
                showAudioFeedback(audioIndex, 'visual');
            }
        }

        /**
         * Stops audio playback for a specific hotspot
         * @param {number} audioIndex - Index of hotspot (0 or 1)
         */
        function stopAudio(audioIndex) {
            const audioSource = currentlyPlayingAudio[audioIndex];
            const audioType = currentlyPlayingType[audioIndex];
            
            if (audioSource) {
                try {
                    if (audioType === 'file' || audioType === 'synthetic') {
                        audioSource.stop();
                    }
                    console.log(`üõë Stopped audio for hotspot ${audioIndex + 1}`);
                } catch (e) {
                    console.warn('Error stopping audio:', e);
                }
                
                currentlyPlayingAudio[audioIndex] = null;
                currentlyPlayingType[audioIndex] = null;
                
                showStopFeedback(audioIndex);
            }
        }

        /**
         * Shows on-screen feedback when audio starts playing
         * @param {number} audioIndex - Hotspot index
         * @param {string} audioType - Type of audio (file/synthetic/visual)
         */
        function showAudioFeedback(audioIndex, audioType = 'visual') {
            const feedback = document.createElement('div');
            feedback.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(74, 158, 255, 0.95);
                color: white;
                padding: 20px 30px;
                border-radius: 10px;
                z-index: 1000;
                font-size: 16px;
                text-align: center;
                border: 2px solid rgba(255, 255, 255, 0.3);
            `;
            
            let message = '';
            if (audioType === 'file') {
                const fileName = audioIndex === 0 ? 'info.mp3' : 'bass.mp3';
                const hotspotColor = audioIndex === 0 ? 'Cyan' : 'Orange';
                message = `üéµ ${hotspotColor} Hotspot\n‚ñ∂Ô∏è Playing: ${fileName}\n\n(Click again to stop)`;
            } else if (audioType === 'synthetic') {
                const hotspotName = audioIndex === 0 ? 'Cyan Hotspot' : 'Orange Hotspot';
                const pitch = audioIndex === 0 ? 'High Tone' : 'Low Tone';
                message = `üîä ${hotspotName}\n‚ñ∂Ô∏è ${pitch} Playing!\n\n(Click again to stop)`;
            } else {
                const fileName = audioIndex === 0 ? 'info.mp3' : 'bass.mp3';
                const hotspotColor = audioIndex === 0 ? 'Cyan' : 'Orange';
                message = `üéØ ${hotspotColor} Hotspot\n${fileName} would play here`;
            }
            
            feedback.textContent = message;
            feedback.style.whiteSpace = 'pre-line';
            document.body.appendChild(feedback);
            
            // Auto-remove after 2 seconds
            setTimeout(() => {
                if (document.body.contains(feedback)) {
                    document.body.removeChild(feedback);
                }
            }, 2000);
        }

        /**
         * Shows feedback when audio is stopped
         * @param {number} audioIndex - Hotspot index
         */
        function showStopFeedback(audioIndex) {
            const feedback = document.createElement('div');
            feedback.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(255, 102, 0, 0.95);
                color: white;
                padding: 20px 30px;
                border-radius: 10px;
                z-index: 1000;
                font-size: 16px;
                text-align: center;
                border: 2px solid rgba(255, 255, 255, 0.3);
            `;
            
            const fileName = audioIndex === 0 ? 'info.mp3' : 'bass.mp3';
            const hotspotColor = audioIndex === 0 ? 'Cyan' : 'Orange';
            const message = `üõë ${hotspotColor} Hotspot\n‚èπÔ∏è Stopped: ${fileName}\n\n(Click again to play)`;
            
            feedback.textContent = message;
            feedback.style.whiteSpace = 'pre-line';
            document.body.appendChild(feedback);
            
            // Auto-remove after 1.5 seconds
            setTimeout(() => {
                if (document.body.contains(feedback)) {
                    document.body.removeChild(feedback);
                }
            }, 1500);
        }

        /**
         * Creates the interactive audio hotspot spheres
         * Two colored spheres with glow effects
         */
        function createHotspots() {
            console.log('üéØ Creating hotspots...');
            
            // Create cyan hotspot (first audio point)
            const hotspot1Geometry = new THREE.SphereGeometry(0.4, 16, 16);
            const hotspot1Material = new THREE.MeshBasicMaterial({ 
                color: 0x00ffff,
                transparent: true,
                opacity: 1.0,
                emissive: 0x003333
            });
            const hotspot1 = new THREE.Mesh(hotspot1Geometry, hotspot1Material);
            hotspot1.position.set(hotspotPositions[0].x, hotspotPositions[0].y, hotspotPositions[0].z);
            hotspot1.userData = { 
                isHotspot: true, 
                audioIndex: 0,
                name: 'Audio Point 1'
            };
            
            // Create glow effect for cyan hotspot
            const hotspot1Glow = new THREE.Mesh(
                new THREE.SphereGeometry(0.6, 16, 16),
                new THREE.MeshBasicMaterial({ 
                    color: 0x00ffff,
                    transparent: true,
                    opacity: 0.5,
                    emissive: 0x001111
                })
            );
            hotspot1Glow.position.copy(hotspot1.position);
            
            // Create orange hotspot (second audio point)
            const hotspot2Geometry = new THREE.SphereGeometry(0.4, 16, 16);
            const hotspot2Material = new THREE.MeshBasicMaterial({ 
                color: 0xff6600,
                transparent: true,
                opacity: 1.0,
                emissive: 0x331100
            });
            const hotspot2 = new THREE.Mesh(hotspot2Geometry, hotspot2Material);
            hotspot2.position.set(hotspotPositions[1].x, hotspotPositions[1].y, hotspotPositions[1].z);
            hotspot2.userData = { 
                isHotspot: true, 
                audioIndex: 1,
                name: 'Audio Point 2'
            };
            
            // Create glow effect for orange hotspot
            const hotspot2Glow = new THREE.Mesh(
                new THREE.SphereGeometry(0.6, 16, 16),
                new THREE.MeshBasicMaterial({ 
                    color: 0xff6600,
                    transparent: true,
                    opacity: 0.5,
                    emissive: 0x110000
                })
            );
            hotspot2Glow.position.copy(hotspot2.position);

            // Add to scene but keep hidden initially
            scene.add(hotspot1);
            scene.add(hotspot1Glow);
            scene.add(hotspot2);
            scene.add(hotspot2Glow);
            
            hotspot1.visible = false;
            hotspot1Glow.visible = false;
            hotspot2.visible = false;
            hotspot2Glow.visible = false;

            // Store in hotspots array for management
            hotspots.push({
                sphere: hotspot1,
                glow: hotspot1Glow,
                audioIndex: 0,
                name: 'Audio Point 1'
            });
            
            hotspots.push({
                sphere: hotspot2,
                glow: hotspot2Glow,
                audioIndex: 1,
                name: 'Audio Point 2'
            });

            console.log('‚úÖ Hotspots created with enhanced visibility');
            initializeSliderControls();        // Initialize hotspot position sliders
            initializeVideoSliderControls();   // Initialize video transform sliders
        }

        /**
         * Initializes slider controls for hotspot positioning
         * Connects HTML range inputs to hotspot position updates
         */
        function initializeSliderControls() {
            // Get all slider elements for cyan hotspot
            const cyanXSlider = document.getElementById('cyan-x');
            const cyanYSlider = document.getElementById('cyan-y');
            const cyanZSlider = document.getElementById('cyan-z');
            const cyanXVal = document.getElementById('cyan-x-val');
            const cyanYVal = document.getElementById('cyan-y-val');
            const cyanZVal = document.getElementById('cyan-z-val');

            // Get all slider elements for orange hotspot
            const orangeXSlider = document.getElementById('orange-x');
            const orangeYSlider = document.getElementById('orange-y');
            const orangeZSlider = document.getElementById('orange-z');
            const orangeXVal = document.getElementById('orange-x-val');
            const orangeYVal = document.getElementById('orange-y-val');
            const orangeZVal = document.getElementById('orange-z-val');

            /**
             * Updates cyan hotspot position from slider values
             */
            function updateCyanPosition() {
                const x = parseFloat(cyanXSlider.value);
                const y = parseFloat(cyanYSlider.value);
                const z = parseFloat(cyanZSlider.value);
                
                hotspotPositions[0] = { x, y, z };
                
                if (hotspots[0]) {
                    hotspots[0].sphere.position.set(x, y, z);
                    hotspots[0].glow.position.set(x, y, z);
                }
                
                cyanXVal.textContent = x.toFixed(1);
                cyanYVal.textContent = y.toFixed(1);
                cyanZVal.textContent = z.toFixed(1);
            }

            /**
             * Updates orange hotspot position from slider values
             */
            function updateOrangePosition() {
                const x = parseFloat(orangeXSlider.value);
                const y = parseFloat(orangeYSlider.value);
                const z = parseFloat(orangeZSlider.value);
                
                hotspotPositions[1] = { x, y, z };
                
                if (hotspots[1]) {
                    hotspots[1].sphere.position.set(x, y, z);
                    hotspots[1].glow.position.set(x, y, z);
                }
                
                orangeXVal.textContent = x.toFixed(1);
                orangeYVal.textContent = y.toFixed(1);
                orangeZVal.textContent = z.toFixed(1);
            }

            // Attach event listeners to sliders
            cyanXSlider.addEventListener('input', updateCyanPosition);
            cyanYSlider.addEventListener('input', updateCyanPosition);
            cyanZSlider.addEventListener('input', updateCyanPosition);
            orangeXSlider.addEventListener('input', updateOrangePosition);
            orangeYSlider.addEventListener('input', updateOrangePosition);
            orangeZSlider.addEventListener('input', updateOrangePosition);

            console.log('‚úÖ Slider controls initialized');
        }

        /**
         * Resets cyan hotspot to default position
         * Made global for HTML button onclick
         */
        function resetCyanPosition() {
            document.getElementById('cyan-x').value = 7;
            document.getElementById('cyan-y').value = -2;
            document.getElementById('cyan-z').value = -2;
            
            hotspotPositions[0] = { x: 7, y: -2, z: -2 };
            
            if (hotspots[0]) {
                hotspots[0].sphere.position.set(7, -2, -2);
                hotspots[0].glow.position.set(7, -2, -2);
            }
            
            document.getElementById('cyan-x-val').textContent = '7.0';
            document.getElementById('cyan-y-val').textContent = '-2.0';
            document.getElementById('cyan-z-val').textContent = '-2.0';
        }

        /**
         * Resets orange hotspot to default position
         * Made global for HTML button onclick
         */
        function resetOrangePosition() {
            document.getElementById('orange-x').value = -2.5;
            document.getElementById('orange-y').value = -3;
            document.getElementById('orange-z').value = 8.1;
            
            hotspotPositions[1] = { x: -2.5, y: -3, z: 8.1 };
            
            if (hotspots[1]) {
                hotspots[1].sphere.position.set(-2.5, -3, 8.1);
                hotspots[1].glow.position.set(-2.5, -3, 8.1);
            }
            
            document.getElementById('orange-x-val').textContent = '-2.5';
            document.getElementById('orange-y-val').textContent = '-3.0';
            document.getElementById('orange-z-val').textContent = '8.1';
        }

        // Make functions global for HTML onclick handlers
        window.resetCyanPosition = resetCyanPosition;
        window.resetOrangePosition = resetOrangePosition;

        // ====== VIDEO POSITIONING FUNCTIONS ======
        /**
         * Updates video screen position, rotation, and scale from sliders
         * Applies transformation to the video mesh in real-time
         */
        function updateVideoPosition() {
            // Get all slider elements
            const videoXSlider = document.getElementById('video-x');
            const videoYSlider = document.getElementById('video-y');
            const videoZSlider = document.getElementById('video-z');
            const videoScaleSlider = document.getElementById('video-scale');
            const videoRotXSlider = document.getElementById('video-rot-x');
            const videoRotYSlider = document.getElementById('video-rot-y');
            const videoRotZSlider = document.getElementById('video-rot-z');
            
            // Get display value elements
            const videoXVal = document.getElementById('video-x-val');
            const videoYVal = document.getElementById('video-y-val');
            const videoZVal = document.getElementById('video-z-val');
            const videoScaleVal = document.getElementById('video-scale-val');
            const videoRotXVal = document.getElementById('video-rot-x-val');
            const videoRotYVal = document.getElementById('video-rot-y-val');
            const videoRotZVal = document.getElementById('video-rot-z-val');

            // Read all transformation values
            const x = parseFloat(videoXSlider.value);
            const y = parseFloat(videoYSlider.value);
            const z = parseFloat(videoZSlider.value);
            const scale = parseFloat(videoScaleSlider.value);
            const rotX = parseFloat(videoRotXSlider.value);
            const rotY = parseFloat(videoRotYSlider.value);
            const rotZ = parseFloat(videoRotZSlider.value);
            
            // Update global tracking variables
            videoPosition = { x, y, z };
            videoScale = scale;
            videoRotation = { x: rotX, y: rotY, z: rotZ };
            
            // Apply transformations to video screen mesh
            if (videoScreen) {
                videoScreen.position.set(x, y, z);
                videoScreen.scale.set(scale, scale, scale);
                // Convert degrees to radians for Three.js rotation
                videoScreen.rotation.set(
                    rotX * Math.PI / 180,
                    rotY * Math.PI / 180,
                    rotZ * Math.PI / 180
                );
                console.log(`üì∫ Video screen: pos(${x}, ${y}, ${z}) scale(${scale}) rot(${rotX}¬∞, ${rotY}¬∞, ${rotZ}¬∞)`);
            }
            
            // Update display values
            videoXVal.textContent = x.toFixed(1);
            videoYVal.textContent = y.toFixed(1);
            videoZVal.textContent = z.toFixed(1);
            videoScaleVal.textContent = scale.toFixed(1);
            videoRotXVal.textContent = rotX + '¬∞';
            videoRotYVal.textContent = rotY + '¬∞';
            videoRotZVal.textContent = rotZ + '¬∞';
        }

        /**
         * Initializes video transformation slider controls
         * Connects HTML range inputs to video transform updates
         */
        function initializeVideoSliderControls() {
            // Get all slider elements
            const videoXSlider = document.getElementById('video-x');
            const videoYSlider = document.getElementById('video-y');
            const videoZSlider = document.getElementById('video-z');
            const videoScaleSlider = document.getElementById('video-scale');
            const videoRotXSlider = document.getElementById('video-rot-x');
            const videoRotYSlider = document.getElementById('video-rot-y');
            const videoRotZSlider = document.getElementById('video-rot-z');

            // Check if sliders exist (DOM might not be ready)
            if (!videoXSlider || !videoYSlider || !videoZSlider || !videoScaleSlider ||
                !videoRotXSlider || !videoRotYSlider || !videoRotZSlider) {
                console.warn('‚ö†Ô∏è Video sliders not found in DOM, retrying in 100ms...');
                setTimeout(initializeVideoSliderControls, 100);
                return;
            }

            // Remove existing listeners to avoid duplicates
            videoXSlider.removeEventListener('input', updateVideoPosition);
            videoYSlider.removeEventListener('input', updateVideoPosition);
            videoZSlider.removeEventListener('input', updateVideoPosition);
            videoScaleSlider.removeEventListener('input', updateVideoPosition);
            videoRotXSlider.removeEventListener('input', updateVideoPosition);
            videoRotYSlider.removeEventListener('input', updateVideoPosition);
            videoRotZSlider.removeEventListener('input', updateVideoPosition);

            // Add event listeners to all sliders
            videoXSlider.addEventListener('input', updateVideoPosition);
            videoYSlider.addEventListener('input', updateVideoPosition);
            videoZSlider.addEventListener('input', updateVideoPosition);
            videoScaleSlider.addEventListener('input', updateVideoPosition);
            videoRotXSlider.addEventListener('input', updateVideoPosition);
            videoRotYSlider.addEventListener('input', updateVideoPosition);
            videoRotZSlider.addEventListener('input', updateVideoPosition);

            console.log('‚úÖ Video slider controls (position, scale, rotation) initialized and connected');
            
            // Debug listeners
            videoXSlider.addEventListener('input', () => {
                console.log('üéõÔ∏è X slider changed to:', videoXSlider.value);
            });
            
            videoScaleSlider.addEventListener('input', () => {
                console.log('üéõÔ∏è Scale slider changed to:', videoScaleSlider.value);
            });
            
            videoRotYSlider.addEventListener('input', () => {
                console.log('üéõÔ∏è Rotation Y slider changed to:', videoRotYSlider.value);
            });
            
            // Initialize display values
            updateVideoPosition();
        }

        /**
         * Resets video screen to default transform (position, scale, rotation)
         * Made global for HTML button onclick
         */
        function resetVideoTransform() {
            // Reset position sliders
            document.getElementById('video-x').value = 0;
            document.getElementById('video-y').value = 1;
            document.getElementById('video-z').value = 2;
            document.getElementById('video-scale').value = 1.0;
            
            // Reset rotation sliders
            document.getElementById('video-rot-x').value = 0;
            document.getElementById('video-rot-y').value = 0;
            document.getElementById('video-rot-z').value = 0;
            
            // Update global variables
            videoPosition = { x: 0, y: 1, z: 2 };
            videoScale = 1.0;
            videoRotation = { x: 0, y: 0, z: 0 };
            
            // Apply to video screen mesh
            if (videoScreen) {
                videoScreen.position.set(0, 1, 2);
                videoScreen.scale.set(1.0, 1.0, 1.0);
                videoScreen.rotation.set(0, 0, 0);
                console.log('üì∫ Video screen reset to default transform');
            }
            
            // Update display values
            updateVideoPosition();
        }

        // Make function global for HTML onclick handler
        window.resetVideoTransform = resetVideoTransform;

        /**
         * Creates orbit controls for viewing inside portal scenes
         * Separate from main gallery controls
         * @returns {OrbitControls} Controls object
         */
        function createSplatControls() {
            const controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 0.5;
            controls.maxDistance = 50;
            controls.enabled = false;  // Disabled until entering portal
            return controls;
        }

        splatControls = createSplatControls();

        /**
         * Creates a single portal object with frame and Gaussian splat viewer
         * @param {Object} config - Portal configuration object
         * @param {number} index - Portal index in array
         * @returns {Object} Portal object with scene, camera, viewer, etc.
         */
        async function createPortal(config, index) {
            console.log(`\nüî∑ Creating portal ${index}: ${config.name}`);

            // Create separate scene for this portal's content
            const portalScene = new THREE.Scene();
            portalScene.background = new THREE.Color(0x1a1a2a);
            
            // Create camera for portal's internal view
            const portalCamera = new THREE.PerspectiveCamera(60, 1, 0.1, 100);
            portalCamera.position.set(0, 1, 3);
            portalCamera.lookAt(0, 0, 0);
            
            // Add lighting to portal scene
            portalScene.add(new THREE.AmbientLight(0xffffff, 0.8));
            const portalDirLight = new THREE.DirectionalLight(0xffffff, 0.5);
            portalDirLight.position.set(5, 5, 5);
            portalScene.add(portalDirLight);
            
            // Create render target for portal texture (high res for quality)
            const portalRenderTarget = new THREE.WebGLRenderTarget(2048, 2048, {
                minFilter: THREE.LinearFilter,
                magFilter: THREE.LinearFilter,
                format: THREE.RGBAFormat
            });

            // Create portal frame group
            const portalGroup = new THREE.Group();
            portalGroup.position.set(config.position.x, config.position.y, config.position.z);

            // Create dark metallic frame
            const frame = new THREE.Mesh(
                new THREE.BoxGeometry(1.5, 2.2, 0.1),
                new THREE.MeshStandardMaterial({ 
                    color: 0x1a1a1a,
                    metalness: 0.8,
                    roughness: 0.2 
                })
            );
            frame.castShadow = true;
            frame.receiveShadow = true;
            portalGroup.add(frame);

            // Create portal surface that displays the splat scene
            const portalSurface = new THREE.Mesh(
                new THREE.PlaneGeometry(1.3, 2),
                new THREE.MeshBasicMaterial({ 
                    map: portalRenderTarget.texture,
                    side: THREE.DoubleSide
                })
            );
            portalSurface.position.z = 0.06;
            portalGroup.add(portalSurface);

            // Create colored glow effect around portal
            const glow = new THREE.Mesh(
                new THREE.PlaneGeometry(1.4, 2.1),
                new THREE.MeshBasicMaterial({ 
                    color: config.color,
                    transparent: true,
                    opacity: 0.2,
                    side: THREE.DoubleSide
                })
            );
            glow.position.z = 0.05;
            portalGroup.add(glow);

            scene.add(portalGroup);

            // Initialize Gaussian Splat viewer for this portal
            let splatViewer = null;
            try {
                console.log(`   üìÑ Loading splat...`);
                
                splatViewer = new GaussianSplats3D.Viewer({
                    threeScene: portalScene,
                    renderer: renderer,
                    camera: portalCamera,
                    selfDrivenMode: false,
                    useBuiltInControls: false,
                    showLoadingSpinner: false,
                    gpuAcceleratedSort: false,
                    integerBasedSort: false,
                    sharedMemoryForWorkers: false,
                    enableSplatSorting: true,
                    halfPrecisionCovariancesOnGPU: true,
                    dynamicScene: false,
                    webXRMode: GaussianSplats3D.WebXRMode.None,
                    renderMode: GaussianSplats3D.RenderMode.Always,
                    logLevel: GaussianSplats3D.LogLevel.Info
                });

                await splatViewer.init();
                console.log(`   ‚úÖ Viewer initialized`);

                // Load the Gaussian splat file
                await splatViewer.addSplatScene(config.splatFile, {
                    progressiveLoad: true,
                    splatAlphaRemovalThreshold: 5,
                    position: [0, 0, 0],
                    rotation: [1, 0, 0, 0],
                    scale: [config.scale, config.scale, config.scale]
                });

                console.log(`   ‚úÖ Portal ${index} splat loaded!`);

            } catch (error) {
                console.error(`   ‚ùå Portal ${index} failed:`, error);
            }

            // Store portal object with all its components
            portals.push({
                index,
                config,
                group: portalGroup,
                scene: portalScene,
                camera: portalCamera,
                renderTarget: portalRenderTarget,
                viewer: splatViewer,
                glow
            });

            return portals[portals.length - 1];
        }

        /**
         * Updates portal camera based on main camera position (parallax effect)
         * @param {Object} portal - Portal object to update
         */
        function updatePortalCamera(portal) {
            const portalPos = portal.group.position;
            const cameraToPortal = new THREE.Vector3().subVectors(camera.position, portalPos);
            const strength = portal.config.parallaxStrength;

            // Apply parallax offset to portal camera
            portal.camera.position.x = -cameraToPortal.x * strength;
            portal.camera.position.y = cameraToPortal.y * strength + 1;
            portal.camera.position.z = cameraToPortal.z * strength + 5;
            portal.camera.lookAt(0, 0, 0);
        }

        // ====== PORTAL INTERACTION ======
        // Raycasting for click detection
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        /**
         * Handles click events for portal entry and hotspot interaction
         */
        renderer.domElement.addEventListener('click', (event) => {
            // Convert mouse position to normalized device coordinates (-1 to +1)
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            if (isInSplatScene) {
                // Inside portal - check for hotspot clicks (only in portal 1)
                if (activePortalIndex === 1) {
                    const hotspotObjects = [];
                    hotspots.forEach(hotspot => {
                        if (hotspot.sphere.visible) {
                            hotspotObjects.push(hotspot.sphere);
                        }
                    });

                    const intersects = raycaster.intersectObjects(hotspotObjects);
                    if (intersects.length > 0) {
                        const clickedHotspot = intersects[0].object;
                        const audioIndex = clickedHotspot.userData.audioIndex;
                        console.log(`üéØ Hotspot clicked: ${clickedHotspot.userData.name}`);
                        
                        initAudioContext();
                        playAudio(audioIndex);
                        
                        return;
                    }
                }
                
            } else {
                // Outside portals - check for portal entry clicks
                portals.forEach((portal) => {
                    const intersects = raycaster.intersectObjects(portal.group.children, true);
                    if (intersects.length > 0) {
                        enterPortal(portal.index);
                    }
                });
            }
        });

        /**
         * Shows proximity prompt when near portals in gallery view
         */
        function updatePortalProximity() {
            if (isInSplatScene) return;

            let nearPortal = false;
            portals.forEach(portal => {
                const distance = camera.position.distanceTo(portal.group.position);
                if (distance < 6) nearPortal = true;
            });

            const prompt = document.getElementById('portal-prompt');
            if (nearPortal) {
                prompt.classList.add('show');
            } else {
                prompt.classList.remove('show');
            }
        }

        /**
         * Enters a portal scene (switches view to inside portal)
         * @param {number} portalIndex - Index of portal to enter
         */
        function enterPortal(portalIndex) {
            console.log(`üö™ Entering portal ${portalIndex}`);
            isInSplatScene = true;
            activePortalIndex = portalIndex;

            // Switch control systems
            controls.enabled = false;
            splatControls.enabled = true;

            // Switch active portal viewer to use main camera
            const activePortal = portals[portalIndex];
            if (activePortal && activePortal.viewer) {
                activePortal.viewer.camera = camera;
                console.log('‚úÖ Switched viewer to main camera');
            }

            // Reset camera position for portal view
            camera.position.set(0, 2, 8);
            camera.lookAt(0, 0, 0);
            splatControls.target.set(0, 0, 0);
            splatControls.update();

            // Change background for immersion
            scene.background = new THREE.Color(0x1a1a2a);

            // Hide gallery elements
            floor.visible = false;
            backWall.visible = false;
            leftWall.visible = false;
            rightWall.visible = false;
            cube.visible = false;
            portals.forEach(p => p.group.visible = false);
            spotlight1.visible = false;
            spotlight2.visible = false;
            spotlight3.visible = false;

            // Show hotspots only in portal 1 (middle portal)
            if (portalIndex === 1) {
                console.log('üéØ Showing hotspots for middle portal');
                hotspots.forEach((hotspot, index) => {
                    hotspot.sphere.visible = true;
                    hotspot.glow.visible = true;
                    
                    if (activePortal && activePortal.scene) {
                        activePortal.scene.add(hotspot.sphere);
                        activePortal.scene.add(hotspot.glow);
                    }
                });
                document.getElementById('hotspot-info').classList.add('show');
                document.getElementById('hotspot-controls').classList.add('show');
            } else {
                // Hide hotspots in other portals
                hotspots.forEach(hotspot => {
                    hotspot.sphere.visible = false;
                    hotspot.glow.visible = false;
                    
                    if (hotspot.sphere.parent && hotspot.sphere.parent !== scene) {
                        hotspot.sphere.parent.remove(hotspot.sphere);
                    }
                    if (hotspot.glow.parent && hotspot.glow.parent !== scene) {
                        hotspot.glow.parent.remove(hotspot.glow);
                    }
                });
                document.getElementById('hotspot-info').classList.remove('show');
                document.getElementById('hotspot-controls').classList.remove('show');
            }

            // Show video controls and add video to portal 2 (third portal)
            if (portalIndex === 2) {
                console.log('üé¨ Showing video controls for portal 3');
                document.getElementById('video-controls').classList.add('show');
                
                // Initialize video sliders when controls are shown
                setTimeout(initializeVideoSliderControls, 100);
                
                if (isVideoActive && videoScreen) {
                    addVideoToPortal(2);
                }
            } else {
                document.getElementById('video-controls').classList.remove('show');
                removeVideoFromPortal();
            }

            // Update instructions for current portal
            let instructionText = `
                <h2>üåÄ Inside ${portals[portalIndex].config.name}</h2>
                <ul>
                    <li>Drag to rotate view</li>
                    <li>Scroll to zoom in/out</li>
                    <li>Explore the 3D space</li>`;
            
            if (portalIndex === 1) {
                instructionText += `<li>üéØ Look for glowing spheres to click!</li>`;
                instructionText += `<li>üîä Click to play/stop audio</li>`;
            }
            
            if (portalIndex === 2) {
                instructionText += `<li>üé¨ Use video controls to start feed!</li>`;
                instructionText += `<li>üì∫ Use sliders to position/rotate video!</li>`;
            }
            
            instructionText += `<li>Press ESC to exit</li>
                </ul>
            `;

            document.getElementById('instructions').innerHTML = instructionText;
            document.getElementById('portal-prompt').classList.remove('show');
        }

        /**
         * Exits current portal and returns to gallery view
         */
        function exitPortal() {
            console.log('üö™ Exiting portal...');
            
            // Restore portal's original camera
            const activePortal = portals[activePortalIndex];
            if (activePortal && activePortal.viewer) {
                activePortal.viewer.camera = activePortal.camera;
                console.log('‚úÖ Restored portal camera');
            }

            // Clean up hotspots and audio from portal scene
            if (activePortalIndex === 1 && activePortal && activePortal.scene) {
                // Stop all playing audio
                for (let i = 0; i < currentlyPlayingAudio.length; i++) {
                    if (currentlyPlayingAudio[i]) {
                        try {
                            currentlyPlayingAudio[i].stop();
                        } catch (e) {
                            console.warn('Error stopping audio on exit:', e);
                        }
                        currentlyPlayingAudio[i] = null;
                        currentlyPlayingType[i] = null;
                    }
                }
                
                // Remove hotspots from portal scene and hide them
                hotspots.forEach(hotspot => {
                    activePortal.scene.remove(hotspot.sphere);
                    activePortal.scene.remove(hotspot.glow);
                    scene.add(hotspot.sphere);
                    scene.add(hotspot.glow);
                    hotspot.sphere.visible = false;
                    hotspot.glow.visible = false;
                });
                console.log('üéØ Hotspots and audio cleaned up from portal scene');
            }

            // Clean up video from portal scene
            if (activePortalIndex === 2) {
                removeVideoFromPortal();
                console.log('üé¨ Video removed from portal scene');
            }

            isInSplatScene = false;
            activePortalIndex = -1;

            // Switch back to gallery controls
            controls.enabled = true;
            splatControls.enabled = false;

            // Reset camera to gallery view
            camera.position.set(0, 1.6, 8);
            controls.target.set(0, 0.8, -3);
            controls.update();

            // Restore gallery background
            scene.background = new THREE.Color(0x0a0a0a);

            // Show all gallery elements
            floor.visible = true;
            backWall.visible = true;
            leftWall.visible = true;
            rightWall.visible = true;
            cube.visible = true;
            portals.forEach(p => p.group.visible = true);
            spotlight1.visible = true;
            spotlight2.visible = true;
            spotlight3.visible = true;

            // Hide all portal-specific UI
            document.getElementById('hotspot-info').classList.remove('show');
            document.getElementById('hotspot-controls').classList.remove('show');
            document.getElementById('video-controls').classList.remove('show');

            // Restore gallery instructions
            document.getElementById('instructions').innerHTML = `
                <h2>üåÄ Gallery Controls</h2>
                <ul>
                    <li>Left click + drag to orbit</li>
                    <li>Scroll to zoom in/out</li>
                    <li>Click any portal to enter</li>
                    <li>Each portal shows different view</li>
                </ul>
            `;
        }

        /**
         * Handles ESC key to exit portals
         */
        window.addEventListener('keydown', (event) => {
            if (event.key === 'Escape' && isInSplatScene) {
                exitPortal();
            }
        });

        // ====== ANIMATION LOOP ======
        /**
         * Main render loop - updates controls, animations, and renders scenes
         */
        function animate() {
            requestAnimationFrame(animate);

            if (isInSplatScene) {
                // Inside portal view
                splatControls.update();

                const activePortal = portals[activePortalIndex];
                if (activePortal && activePortal.viewer) {
                    activePortal.viewer.update();
                    
                    renderer.setRenderTarget(null);
                    activePortal.viewer.render();
                }

                // Animate hotspots if visible (portal 1)
                if (activePortalIndex === 1) {
                    const time = Date.now() * 0.002;
                    hotspots.forEach((hotspot, index) => {
                        if (hotspot.sphere.visible && hotspot.sphere.parent === activePortal.scene) {
                            // Pulse opacity
                            hotspot.sphere.material.opacity = 0.7 + Math.sin(time * 3 + index * 2) * 0.3;
                            hotspot.glow.material.opacity = 0.4 + Math.sin(time * 2 + index * 2) * 0.2;
                            
                            // Floating animation
                            const baseY = hotspotPositions[index].y;
                            const floatOffset = Math.sin(time * 1.5 + index * 3) * 0.2;
                            hotspot.sphere.position.y = baseY + floatOffset;
                            hotspot.glow.position.copy(hotspot.sphere.position);
                        }
                    });
                }

                // Update video texture if active (portal 2)
                if (activePortalIndex === 2 && videoScreen && videoScreen.visible && isVideoActive) {
                    // Video position is controlled by sliders, no automatic animation
                    // Just update the video texture
                    if (videoTexture && videoElement) {
                        // Check if video is ready and playing
                        if (videoElement.readyState >= videoElement.HAVE_CURRENT_DATA && 
                            !videoElement.paused && 
                            videoElement.currentTime > 0) {
                            videoTexture.needsUpdate = true;
                            
                            // Debug log occasionally (every 5 seconds)
                            const time = Date.now() * 0.001;
                            if (Math.floor(time) % 5 === 0 && Math.floor(time * 10) % 10 === 0) {
                                console.log('üé¨ Video texture updated:', {
                                    currentTime: videoElement.currentTime.toFixed(1),
                                    videoSize: `${videoElement.videoWidth}x${videoElement.videoHeight}`,
                                    position: `(${videoScreen.position.x.toFixed(1)}, ${videoScreen.position.y.toFixed(1)}, ${videoScreen.position.z.toFixed(1)})`,
                                    rotation: `(${(videoScreen.rotation.x * 180 / Math.PI).toFixed(0)}¬∞, ${(videoScreen.rotation.y * 180 / Math.PI).toFixed(0)}¬∞, ${(videoScreen.rotation.z * 180 / Math.PI).toFixed(0)}¬∞)`,
                                    readyState: videoElement.readyState,
                                    paused: videoElement.paused
                                });
                            }
                        } else {
                            // Video not ready - try to play it
                            if (videoElement.paused && videoElement.readyState >= videoElement.HAVE_METADATA) {
                                videoElement.play().catch(e => {
                                    console.warn('Video autoplay failed:', e);
                                });
                            }
                        }
                    }
                }
            } else {
                // Gallery view
                controls.update();
                updatePortalProximity();

                // Rotate decorative cube
                cube.rotation.x += 0.005;
                cube.rotation.y += 0.005;

                // Update all portal cameras and render portal textures
                portals.forEach(portal => {
                    updatePortalCamera(portal);

                    if (portal.viewer) {
                        portal.viewer.update();
                        
                        // Render portal scene to texture
                        renderer.setRenderTarget(portal.renderTarget);
                        portal.viewer.render();
                        renderer.setRenderTarget(null);
                    }

                    // Animate portal glow
                    const time = Date.now() * 0.001;
                    portal.glow.material.opacity = 0.2 + Math.sin(time * 2 + portal.index) * 0.1;
                });

                // Render main gallery scene
                renderer.render(scene, camera);
            }
        }

        // ====== INITIALIZATION ======
        /**
         * Initializes the entire application
         * Loads all portals and starts animation loop
         */
        async function init() {
            document.getElementById('loading-text').textContent = 'Creating portal gallery with video support...';

            // Create interactive hotspots
            createHotspots();

            // Load all portals sequentially
            for (let i = 0; i < PORTAL_CONFIGS.length; i++) {
                document.getElementById('loading-text').textContent = `Loading portal ${i + 1}/${PORTAL_CONFIGS.length}...`;
                await createPortal(PORTAL_CONFIGS[i], i);
            }

            // Update UI and start animation
            document.getElementById('portal-count').textContent = portals.length;
            document.getElementById('loading').style.display = 'none';
            document.getElementById('instructions').style.display = 'block';
            document.getElementById('gallery-info').style.display = 'block';
            document.getElementById('file-info').style.display = 'block';

            animate();
            console.log('‚úÖ Portal gallery with video and hotspots ready!');
        }

        // ====== WINDOW RESIZE ======
        /**
         * Handles window resize events
         * Updates camera aspect ratio and renderer size
         */
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // ====== START APPLICATION ======
        init().catch(err => {
            console.error('Init failed:', err);
            document.getElementById('loading-text').textContent = 'Error: ' + err.message;
        });
    </script>
</body>
</html>