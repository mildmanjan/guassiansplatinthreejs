<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gaussian Splat Development Log</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            overflow: hidden;
            background: #000;
        }
        #canvas-container {
            width: 100vw;
            height: 100vh;
        }
        #instructions {
            position: fixed;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            font-size: 14px;
            max-width: 300px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(74, 158, 255, 0.3);
            z-index: 100;
        }
        #instructions h2 {
            margin: 0 0 15px 0;
            font-size: 18px;
            color: #4a9eff;
        }
        #instructions ul {
            list-style: none;
            padding: 0;
        }
        #instructions li {
            margin: 8px 0;
            padding-left: 20px;
            position: relative;
        }
        #instructions li:before {
            content: "‚Üí";
            position: absolute;
            left: 0;
            color: #4a9eff;
        }
        #loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 20px;
            text-align: center;
            background: rgba(0, 0, 0, 0.8);
            padding: 30px;
            border-radius: 10px;
            min-width: 300px;
            z-index: 1000;
        }
        .spinner {
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-top: 3px solid #4a9eff;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        #portal-prompt {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            background: rgba(74, 158, 255, 0.9);
            padding: 20px 40px;
            border-radius: 10px;
            font-size: 18px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 200;
        }
        #portal-prompt.show {
            opacity: 1;
        }
        #file-info {
            position: fixed;
            bottom: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 8px;
            font-size: 12px;
            font-family: monospace;
            z-index: 100;
        }
        #gallery-info {
            position: fixed;
            top: 20px;
            right: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            font-size: 14px;
            max-width: 300px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(74, 158, 255, 0.3);
            z-index: 100;
        }
        #gallery-info h2 {
            margin: 0 0 15px 0;
            font-size: 18px;
            color: #4a9eff;
        }
        #hotspot-info {
            position: fixed;
            bottom: 20px;
            right: 20px;
            color: white;
            background: rgba(255, 102, 0, 0.9);
            padding: 15px;
            border-radius: 8px;
            font-size: 14px;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 100;
        }
        #hotspot-info.show {
            opacity: 1;
        }
        #hotspot-controls {
            position: fixed;
            bottom: 20px;
            right: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.9);
            padding: 20px;
            border-radius: 10px;
            font-size: 12px;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 100;
            max-width: 300px;
            border: 1px solid rgba(74, 158, 255, 0.3);
        }
        #hotspot-controls.show {
            opacity: 1;
        }
        #hotspot-controls h3 {
            margin: 0 0 15px 0;
            font-size: 14px;
            color: #4a9eff;
        }
        .hotspot-slider-group {
            margin-bottom: 15px;
            padding: 10px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 5px;
        }
        .hotspot-slider-group h4 {
            margin: 0 0 10px 0;
            font-size: 12px;
        }
        .cyan-group h4 {
            color: #00ffff;
        }
        .orange-group h4 {
            color: #ff6600;
        }
        .slider-row {
            display: flex;
            align-items: center;
            margin: 5px 0;
        }
        .slider-row label {
            width: 15px;
            font-weight: bold;
        }
        .slider-row input[type="range"] {
            flex: 1;
            margin: 0 8px;
            height: 20px;
        }
        .slider-row span {
            width: 40px;
            text-align: right;
            font-family: monospace;
            font-size: 11px;
        }
        .reset-btn {
            background: rgba(74, 158, 255, 0.8);
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 10px;
            margin-top: 5px;
        }
        .reset-btn:hover {
            background: rgba(74, 158, 255, 1);
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    
    <div id="loading">
        <div class="spinner"></div>
        <div id="loading-text">Loading Gallery...</div>
    </div>
    
    <div id="instructions" style="display: none;">
        <h2>üåÄ Gallery Controls</h2>
        <ul>
            <li>Left click + drag to orbit</li>
            <li>Scroll to zoom in/out</li>
            <li>Click any portal to enter</li>
            <li>Each portal shows different view</li>
        </ul>
    </div>
    
    <div id="gallery-info" style="display: none;">
        <h2>üìä Portal Description</h2>
        <div style="font-size: 12px; line-height: 1.8;">
            <div style="color: #4a9eff;">‚óè Portal 1: first test guass</div>
            <div style="color: #ff6b6b;">‚óè Portal 2: Sony A7S & SuperPoint SuperGlue method Nov 2nd (üéØ Interactive Hotspots)</div>
            <div style="color: #51cf66;">‚óè Portal 3: Reference(0.1)</div>
        </div>
    </div>
    
    <div id="file-info" style="display: none;">
        <div>üìÅ Gallery loaded successfully</div>
        <div>üé® <span id="portal-count">0</span> Portals Active</div>
    </div>

    <div id="portal-prompt">
        Click portal to enter the 3D scene!
    </div>

    <div id="hotspot-info">
        üéØ Click glowing spheres! (Cyan=info.mp3, Orange=bass.mp3) Click again to stop!
    </div>

    <div id="hotspot-controls">
        <h3>üéØ Hotspot Position Controls</h3>
        
        <div class="hotspot-slider-group cyan-group">
            <h4>Cyan Hotspot (info.mp3)</h4>
            <div class="slider-row">
                <label>X:</label>
                <input type="range" id="cyan-x" min="-12" max="12" step="0.1" value="7">
                <span id="cyan-x-val">7.0</span>
            </div>
            <div class="slider-row">
                <label>Y:</label>
                <input type="range" id="cyan-y" min="-4" max="4" step="0.1" value="-2">
                <span id="cyan-y-val">-2.0</span>
            </div>
            <div class="slider-row">
                <label>Z:</label>
                <input type="range" id="cyan-z" min="-4" max="10" step="0.1" value="-2">
                <span id="cyan-z-val">-2.0</span>
            </div>
            <button class="reset-btn" onclick="resetCyanPosition()">Reset</button>
        </div>

        <div class="hotspot-slider-group orange-group">
            <h4>Orange Hotspot (bass.mp3)</h4>
            <div class="slider-row">
                <label>X:</label>
                <input type="range" id="orange-x" min="-12" max="12" step="0.1" value="-2.5">
                <span id="orange-x-val">-2.5</span>
            </div>
            <div class="slider-row">
                <label>Y:</label>
                <input type="range" id="orange-y" min="-4" max="4" step="0.1" value="-3">
                <span id="orange-y-val">-3.0</span>
            </div>
            <div class="slider-row">
                <label>Z:</label>
                <input type="range" id="orange-z" min="-4" max="10" step="0.1" value="8.1">
                <span id="orange-z-val">8.1</span>
            </div>
            <button class="reset-btn" onclick="resetOrangePosition()">Reset</button>
        </div>
        
        <div style="margin-top: 15px; font-size: 10px; color: #ccc;">
            Move sliders to position hotspots! Range: X/Y ¬±12/¬±4, Z -4‚Üí10
        </div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import * as GaussianSplats3D from 'https://cdn.jsdelivr.net/npm/@mkkellogg/gaussian-splats-3d@latest/build/gaussian-splats-3d.module.min.js';

        // ====== PORTAL CONFIGURATION ======
        // ‚úÖ Using EXACT same URL as your working single portal
        const PORTAL_CONFIGS = [
            {
                name: "First Guassian Test iPhone and Record3D",
                splatFile: "https://huggingface.co/mysterytreebeast/gaussian-splat-models/resolve/main/02112025Morning.ply",
                //splatFile: "scan2.ply",
                position: { x: -5, y: 0.5, z: -5 }, // Lowered from 1.5 to 0.5
                color: 0x4a9eff,
                parallaxStrength: 0.5,
                scale: 5
            },
            {
                name: "using SuperPoint/SuperGlue technique.Smaller photoset 107 pics, faster, better results",
                splatFile: "https://huggingface.co/mysterytreebeast/gaussian-splat-models/resolve/main/frontroomSuperGlue2.ply",
                //splatFile:"frontroomSplat211025.ply",
                position: { x: 0, y: 0.5, z: -6 }, // Lowered from 1.5 to 0.5
                color: 0xff6b6b,
                parallaxStrength: 0.3,
                scale: 5
            },
            {
                name: "reference)",
                splatFile: "https://huggingface.co/mysterytreebeast/gaussian-splat-models/resolve/main/InteriorDesign.ply",
                position: { x: 5, y: 0.5, z: -5 }, // Lowered from 1.5 to 0.5
                color: 0x51cf66,
                parallaxStrength: 0.1,
                scale: 5
            }
        ];

        // ====== MAIN SCENE SETUP ======
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0a0a);

        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 1.6, 8);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        document.getElementById('canvas-container').appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 3;
        controls.maxDistance = 20;
        controls.maxPolarAngle = Math.PI / 2;
        controls.target.set(0, 0.8, -3); // Lowered from 1.6 to 0.8 to match portal height

        // ====== DRAMATIC LIGHTING (from working code) ======
        scene.add(new THREE.AmbientLight(0x111111, 0.2));

        const spotlight1 = new THREE.SpotLight(0x4a9eff, 10);
        spotlight1.position.set(-5, 8, -3);
        spotlight1.angle = Math.PI / 5;
        spotlight1.penumbra = 0.6;
        spotlight1.decay = 1.5;
        spotlight1.distance = 20;
        spotlight1.castShadow = true;
        spotlight1.target.position.set(-5, 0.5, -5); // Updated to match new portal height
        scene.add(spotlight1);
        scene.add(spotlight1.target);

        const spotlight2 = new THREE.SpotLight(0xff3333, 10);
        spotlight2.position.set(0, 8, -4);
        spotlight2.angle = Math.PI / 5;
        spotlight2.penumbra = 0.6;
        spotlight2.decay = 1.5;
        spotlight2.distance = 20;
        spotlight2.castShadow = true;
        spotlight2.target.position.set(0, 0.5, -6); // Updated to match new portal height
        scene.add(spotlight2);
        scene.add(spotlight2.target);

        const spotlight3 = new THREE.SpotLight(0xaaccff, 10);
        spotlight3.position.set(5, 8, -3);
        spotlight3.angle = Math.PI / 5;
        spotlight3.penumbra = 0.7;
        spotlight3.decay = 1.5;
        spotlight3.distance = 20;
        spotlight3.castShadow = true;
        spotlight3.target.position.set(5, 0.5, -5); // Updated to match new portal height
        scene.add(spotlight3);
        scene.add(spotlight3.target);

        // ====== ROOM GEOMETRY (from working code) ======
        const floor = new THREE.Mesh(
            new THREE.PlaneGeometry(30, 30),
            new THREE.MeshStandardMaterial({ color: 0x1fffff })
        );
        floor.rotation.x = -Math.PI / 2;
        floor.position.y = -1;
        floor.receiveShadow = true;
        scene.add(floor);

        const wallMat = new THREE.MeshStandardMaterial({ 
            color: 0xffffff, 
            side: THREE.DoubleSide 
        });
        const backWall = new THREE.Mesh(new THREE.PlaneGeometry(30, 10), wallMat);
        backWall.position.set(0, 4, -8);
        backWall.receiveShadow = true;
        scene.add(backWall);

        const leftWall = new THREE.Mesh(new THREE.PlaneGeometry(20, 10), wallMat);
        leftWall.position.set(-10, 4, 0);
        leftWall.rotation.y = Math.PI / 2;
        leftWall.receiveShadow = true;
        scene.add(leftWall);

        const rightWall = new THREE.Mesh(new THREE.PlaneGeometry(20, 10), wallMat);
        rightWall.position.set(10, 4, 0);
        rightWall.rotation.y = -Math.PI / 2;
        rightWall.receiveShadow = true;
        scene.add(rightWall);

        const cube = new THREE.Mesh(
            new THREE.BoxGeometry(0.8, 0.8, 0.8),
            new THREE.MeshStandardMaterial({ color: 0xFFFF00 })
        );
        cube.position.set(-1, 0, -5);
        cube.castShadow = true;
        cube.receiveShadow = true;
        scene.add(cube);

        // ====== PORTAL SYSTEM ======
        const portals = [];
        let activePortalIndex = -1;
        let isInSplatScene = false;
        let splatControls = null;

        // ====== HOTSPOT SYSTEM ======
        const hotspots = [];
        let audioContext = null;
        
        // Audio tracking system for stop/play functionality
        let currentlyPlayingAudio = [null, null]; // Track audio sources for each hotspot
        let currentlyPlayingType = [null, null];  // Track type: 'file', 'synthetic', or null
        
        // Hotspot position tracking
        let hotspotPositions = [
            { x: 7, y: -2, z: -2 },        // Cyan hotspot position
            { x: -2.5, y: -3, z: 8.1 }     // Orange hotspot new position
        ];
        
        // Audio files - Replace these paths with your own audio files
        // For now, we'll use synthetic audio generation which always works
        // 
        // TO USE YOUR OWN AUDIO FILES:
        // 1. Place your audio files in the same folder as this HTML file
        // 2. Replace 'null' with your file paths like this:
        //    'your-audio-1.mp3', 'your-audio-2.wav'
        // 3. Supported formats: .mp3, .wav, .ogg, .m4a
        //
        const AUDIO_FILES = [
            'info.mp3',  // Cyan hotspot (right side, higher position) will play info.mp3
            'bass.mp3'   // Orange hotspot (left side, forward/closer) will play bass.mp3
        ];

        // HOTSPOT MAPPING:
        // Index 0 (Cyan sphere): info.mp3  - Position: (2, 1.5, 3) - Right side
        // Index 1 (Orange sphere): bass.mp3 - Position: (-1, 1, 6) - Left side, closer

        // Create synthetic audio tones (always works, no network needed)
        function createSyntheticAudio(audioIndex) {
            if (!audioContext) return null;
            
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            // Different tones for different hotspots
            const frequencies = [800, 400]; // Cyan = higher pitch, Orange = lower pitch
            const frequency = frequencies[audioIndex] || 440;
            
            oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
            oscillator.type = 'sine';
            
            // Create a nice envelope
            gainNode.gain.setValueAtTime(0, audioContext.currentTime);
            gainNode.gain.linearRampToValueAtTime(0.3, audioContext.currentTime + 0.1);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.8);
            
            oscillator.start();
            oscillator.stop(audioContext.currentTime + 0.8);
            
            return oscillator; // Return the oscillator so it can be tracked
        }

        // Initialize audio context (required for modern browsers)
        function initAudioContext() {
            if (!audioContext) {
                try {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                } catch (e) {
                    console.warn('AudioContext not supported, falling back to HTML5 Audio');
                }
            }
        }

        // Play audio from URL or generate synthetic audio with stop/play toggle
        async function playAudio(audioIndex) {
            console.log(`üîä Audio control for hotspot ${audioIndex + 1}`);
            
            // Check if audio is currently playing for this hotspot
            if (currentlyPlayingAudio[audioIndex]) {
                // Stop currently playing audio
                stopAudio(audioIndex);
                return;
            }
            
            try {
                initAudioContext();
                
                // Resume audio context if suspended (browser autoplay policy)
                if (audioContext && audioContext.state === 'suspended') {
                    await audioContext.resume();
                }

                const audioUrl = AUDIO_FILES[audioIndex];
                
                if (audioUrl) {
                    // Try to load external audio file
                    try {
                        const response = await fetch(audioUrl);
                        const arrayBuffer = await response.arrayBuffer();
                        const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                        
                        const source = audioContext.createBufferSource();
                        source.buffer = audioBuffer;
                        source.connect(audioContext.destination);
                        
                        // Track this audio source
                        currentlyPlayingAudio[audioIndex] = source;
                        currentlyPlayingType[audioIndex] = 'file';
                        
                        // Clean up when audio ends naturally
                        source.onended = () => {
                            currentlyPlayingAudio[audioIndex] = null;
                            currentlyPlayingType[audioIndex] = null;
                        };
                        
                        source.start();
                        console.log('‚úÖ External audio file playing');
                        
                        // Show visual feedback
                        showAudioFeedback(audioIndex, 'file');
                        return;
                    } catch (fetchError) {
                        console.warn('External audio failed, using synthetic audio:', fetchError);
                    }
                }
                
                // Use synthetic audio (always works)
                if (audioContext) {
                    const oscillator = createSyntheticAudio(audioIndex);
                    if (oscillator) {
                        // Track this audio source
                        currentlyPlayingAudio[audioIndex] = oscillator;
                        currentlyPlayingType[audioIndex] = 'synthetic';
                        
                        // Clean up when audio ends naturally
                        oscillator.onended = () => {
                            currentlyPlayingAudio[audioIndex] = null;
                            currentlyPlayingType[audioIndex] = null;
                        };
                        
                        console.log('‚úÖ Synthetic audio playing');
                        
                        // Show visual feedback
                        showAudioFeedback(audioIndex, 'synthetic');
                    }
                } else {
                    throw new Error('No AudioContext available');
                }
                
            } catch (error) {
                console.error('All audio methods failed:', error);
                // Show visual feedback as last resort
                showAudioFeedback(audioIndex, 'visual');
            }
        }

        // Stop audio for a specific hotspot
        function stopAudio(audioIndex) {
            const audioSource = currentlyPlayingAudio[audioIndex];
            const audioType = currentlyPlayingType[audioIndex];
            
            if (audioSource) {
                try {
                    if (audioType === 'file' || audioType === 'synthetic') {
                        audioSource.stop();
                    }
                    console.log(`üõë Stopped audio for hotspot ${audioIndex + 1}`);
                } catch (e) {
                    console.warn('Error stopping audio:', e);
                }
                
                // Clear tracking
                currentlyPlayingAudio[audioIndex] = null;
                currentlyPlayingType[audioIndex] = null;
                
                // Show stop feedback
                showStopFeedback(audioIndex);
            }
        }

        // Show visual feedback when audio plays or fails
        function showAudioFeedback(audioIndex, audioType = 'visual') {
            const feedback = document.createElement('div');
            feedback.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(74, 158, 255, 0.95);
                color: white;
                padding: 20px 30px;
                border-radius: 10px;
                z-index: 1000;
                font-size: 16px;
                text-align: center;
                border: 2px solid rgba(255, 255, 255, 0.3);
            `;
            
            let message = '';
            if (audioType === 'file') {
                const fileName = audioIndex === 0 ? 'info.mp3' : 'bass.mp3';
                const hotspotColor = audioIndex === 0 ? 'Cyan' : 'Orange';
                message = `üéµ ${hotspotColor} Hotspot\n‚ñ∂Ô∏è Playing: ${fileName}\n\n(Click again to stop)`;
            } else if (audioType === 'synthetic') {
                const hotspotName = audioIndex === 0 ? 'Cyan Hotspot' : 'Orange Hotspot';
                const pitch = audioIndex === 0 ? 'High Tone' : 'Low Tone';
                message = `üîä ${hotspotName}\n‚ñ∂Ô∏è ${pitch} Playing!\n\n(Click again to stop)`;
            } else {
                const fileName = audioIndex === 0 ? 'info.mp3' : 'bass.mp3';
                const hotspotColor = audioIndex === 0 ? 'Cyan' : 'Orange';
                message = `üéØ ${hotspotColor} Hotspot\n${fileName} would play here`;
            }
            
            feedback.textContent = message;
            feedback.style.whiteSpace = 'pre-line'; // Allow line breaks
            document.body.appendChild(feedback);
            
            setTimeout(() => {
                if (document.body.contains(feedback)) {
                    document.body.removeChild(feedback);
                }
            }, 2000);
        }

        // Show visual feedback when audio is stopped
        function showStopFeedback(audioIndex) {
            const feedback = document.createElement('div');
            feedback.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(255, 102, 0, 0.95);
                color: white;
                padding: 20px 30px;
                border-radius: 10px;
                z-index: 1000;
                font-size: 16px;
                text-align: center;
                border: 2px solid rgba(255, 255, 255, 0.3);
            `;
            
            const fileName = audioIndex === 0 ? 'info.mp3' : 'bass.mp3';
            const hotspotColor = audioIndex === 0 ? 'Cyan' : 'Orange';
            const message = `üõë ${hotspotColor} Hotspot\n‚èπÔ∏è Stopped: ${fileName}\n\n(Click again to play)`;
            
            feedback.textContent = message;
            feedback.style.whiteSpace = 'pre-line';
            document.body.appendChild(feedback);
            
            setTimeout(() => {
                if (document.body.contains(feedback)) {
                    document.body.removeChild(feedback);
                }
            }, 1500);
        }

        // Create hotspot objects
        function createHotspots() {
            console.log('üéØ Creating hotspots...');
            
            // Hotspot 1 - SMALLER cyan sphere, lower and to the right
            const hotspot1Geometry = new THREE.SphereGeometry(0.4, 16, 16); // Reduced from 0.8 to 0.4
            const hotspot1Material = new THREE.MeshBasicMaterial({ 
                color: 0x00ffff,
                transparent: true,
                opacity: 1.0, // Full opacity to ensure visibility
                emissive: 0x003333 // Add emissive glow
            });
            const hotspot1 = new THREE.Mesh(hotspot1Geometry, hotspot1Material);
            hotspot1.position.set(hotspotPositions[0].x, hotspotPositions[0].y, hotspotPositions[0].z);
            hotspot1.userData = { 
                isHotspot: true, 
                audioIndex: 0,
                name: 'Audio Point 1'
            };
            
            // Add pulsing glow effect - smaller
            const hotspot1Glow = new THREE.Mesh(
                new THREE.SphereGeometry(0.6, 16, 16), // Reduced from 1.2 to 0.6
                new THREE.MeshBasicMaterial({ 
                    color: 0x00ffff,
                    transparent: true,
                    opacity: 0.5, // Higher opacity for visibility
                    emissive: 0x001111
                })
            );
            hotspot1Glow.position.copy(hotspot1.position);
            
            // Hotspot 2 - SMALLER orange sphere, forward and down
            const hotspot2Geometry = new THREE.SphereGeometry(0.4, 16, 16); // Reduced from 0.8 to 0.4
            const hotspot2Material = new THREE.MeshBasicMaterial({ 
                color: 0xff6600,
                transparent: true,
                opacity: 1.0, // Full opacity to ensure visibility
                emissive: 0x331100 // Add emissive glow
            });
            const hotspot2 = new THREE.Mesh(hotspot2Geometry, hotspot2Material);
            hotspot2.position.set(hotspotPositions[1].x, hotspotPositions[1].y, hotspotPositions[1].z);
            hotspot2.userData = { 
                isHotspot: true, 
                audioIndex: 1,
                name: 'Audio Point 2'
            };
            
            // Add pulsing glow effect - smaller
            const hotspot2Glow = new THREE.Mesh(
                new THREE.SphereGeometry(0.6, 16, 16), // Reduced from 1.2 to 0.6
                new THREE.MeshBasicMaterial({ 
                    color: 0xff6600,
                    transparent: true,
                    opacity: 0.5, // Higher opacity for visibility
                    emissive: 0x110000
                })
            );
            hotspot2Glow.position.copy(hotspot2.position);

            // Add to scene but make invisible initially
            scene.add(hotspot1);
            scene.add(hotspot1Glow);
            scene.add(hotspot2);
            scene.add(hotspot2Glow);
            
            hotspot1.visible = false;
            hotspot1Glow.visible = false;
            hotspot2.visible = false;
            hotspot2Glow.visible = false;

            hotspots.push({
                sphere: hotspot1,
                glow: hotspot1Glow,
                audioIndex: 0,
                name: 'Audio Point 1'
            });
            
            hotspots.push({
                sphere: hotspot2,
                glow: hotspot2Glow,
                audioIndex: 1,
                name: 'Audio Point 2'
            });

            console.log('‚úÖ Hotspots created with enhanced visibility');
            console.log(`   Cyan hotspot at: (${hotspot1.position.x}, ${hotspot1.position.y}, ${hotspot1.position.z})`);
            console.log(`   Orange hotspot at: (${hotspot2.position.x}, ${hotspot2.position.y}, ${hotspot2.position.z})`);
            
            // Initialize slider controls
            initializeSliderControls();
        }

        // Initialize slider controls
        function initializeSliderControls() {
            // Cyan hotspot sliders
            const cyanXSlider = document.getElementById('cyan-x');
            const cyanYSlider = document.getElementById('cyan-y');
            const cyanZSlider = document.getElementById('cyan-z');
            const cyanXVal = document.getElementById('cyan-x-val');
            const cyanYVal = document.getElementById('cyan-y-val');
            const cyanZVal = document.getElementById('cyan-z-val');

            // Orange hotspot sliders
            const orangeXSlider = document.getElementById('orange-x');
            const orangeYSlider = document.getElementById('orange-y');
            const orangeZSlider = document.getElementById('orange-z');
            const orangeXVal = document.getElementById('orange-x-val');
            const orangeYVal = document.getElementById('orange-y-val');
            const orangeZVal = document.getElementById('orange-z-val');

            // Update functions
            function updateCyanPosition() {
                const x = parseFloat(cyanXSlider.value);
                const y = parseFloat(cyanYSlider.value);
                const z = parseFloat(cyanZSlider.value);
                
                hotspotPositions[0] = { x, y, z };
                
                if (hotspots[0]) {
                    hotspots[0].sphere.position.set(x, y, z);
                    hotspots[0].glow.position.set(x, y, z);
                }
                
                cyanXVal.textContent = x.toFixed(1);
                cyanYVal.textContent = y.toFixed(1);
                cyanZVal.textContent = z.toFixed(1);
                
                console.log(`üéØ Cyan hotspot moved to: (${x}, ${y}, ${z})`);
            }

            function updateOrangePosition() {
                const x = parseFloat(orangeXSlider.value);
                const y = parseFloat(orangeYSlider.value);
                const z = parseFloat(orangeZSlider.value);
                
                hotspotPositions[1] = { x, y, z };
                
                if (hotspots[1]) {
                    hotspots[1].sphere.position.set(x, y, z);
                    hotspots[1].glow.position.set(x, y, z);
                }
                
                orangeXVal.textContent = x.toFixed(1);
                orangeYVal.textContent = y.toFixed(1);
                orangeZVal.textContent = z.toFixed(1);
                
                console.log(`üéØ Orange hotspot moved to: (${x}, ${y}, ${z})`);
            }

            // Add event listeners
            cyanXSlider.addEventListener('input', updateCyanPosition);
            cyanYSlider.addEventListener('input', updateCyanPosition);
            cyanZSlider.addEventListener('input', updateCyanPosition);
            orangeXSlider.addEventListener('input', updateOrangePosition);
            orangeYSlider.addEventListener('input', updateOrangePosition);
            orangeZSlider.addEventListener('input', updateOrangePosition);

            console.log('‚úÖ Slider controls initialized');
        }

        // Reset functions (called by buttons)
        function resetCyanPosition() {
            document.getElementById('cyan-x').value = 7;
            document.getElementById('cyan-y').value = -2;
            document.getElementById('cyan-z').value = -2;
            
            hotspotPositions[0] = { x: 7, y: -2, z: -2 };
            
            if (hotspots[0]) {
                hotspots[0].sphere.position.set(7, -2, -2);
                hotspots[0].glow.position.set(7, -2, -2);
            }
            
            document.getElementById('cyan-x-val').textContent = '7.0';
            document.getElementById('cyan-y-val').textContent = '-2.0';
            document.getElementById('cyan-z-val').textContent = '-2.0';
            
            console.log('üéØ Cyan hotspot reset to default position (7, -2, -2)');
        }

        function resetOrangePosition() {
            document.getElementById('orange-x').value = -2.5;
            document.getElementById('orange-y').value = -3;
            document.getElementById('orange-z').value = 8.1;
            
            hotspotPositions[1] = { x: -2.5, y: -3, z: 8.1 };
            
            if (hotspots[1]) {
                hotspots[1].sphere.position.set(-2.5, -3, 8.1);
                hotspots[1].glow.position.set(-2.5, -3, 8.1);
            }
            
            document.getElementById('orange-x-val').textContent = '-2.5';
            document.getElementById('orange-y-val').textContent = '-3.0';
            document.getElementById('orange-z-val').textContent = '8.1';
            
            console.log('üéØ Orange hotspot reset to default position (-2.5, -3, 8.1)');
        }

        // Make reset functions globally accessible for HTML buttons
        window.resetCyanPosition = resetCyanPosition;
        window.resetOrangePosition = resetOrangePosition;

        function createSplatControls() {
            const controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 0.5;
            controls.maxDistance = 50;
            controls.enabled = false;
            return controls;
        }

        splatControls = createSplatControls();

        /**
         * Create portal - EXACTLY MATCHING working single portal structure
         */
        async function createPortal(config, index) {
            console.log(`\nüî∑ Creating portal ${index}: ${config.name}`);

            // ‚úÖ EXACT STRUCTURE from working code
            const portalScene = new THREE.Scene();
            portalScene.background = new THREE.Color(0x1a1a2a);
            
            // ‚úÖ EXACT camera setup from working code
            const portalCamera = new THREE.PerspectiveCamera(60, 1, 0.1, 100);
            portalCamera.position.set(0, 1, 3);
            portalCamera.lookAt(0, 0, 0);
            
            // ‚úÖ EXACT lighting from working code
            portalScene.add(new THREE.AmbientLight(0xffffff, 0.8));
            const portalDirLight = new THREE.DirectionalLight(0xffffff, 0.5);
            portalDirLight.position.set(5, 5, 5);
            portalScene.add(portalDirLight);
            
            // ‚úÖ EXACT render target from working code
            const portalRenderTarget = new THREE.WebGLRenderTarget(2048, 2048, {
                minFilter: THREE.LinearFilter,
                magFilter: THREE.LinearFilter,
                format: THREE.RGBAFormat
            });

            // Create portal geometry
            const portalGroup = new THREE.Group();
            portalGroup.position.set(config.position.x, config.position.y, config.position.z);

            const frame = new THREE.Mesh(
                new THREE.BoxGeometry(1.5, 2.2, 0.1), // Reduced from 2.2, 3.2
                new THREE.MeshStandardMaterial({ 
                    color: 0x1a1a1a,
                    metalness: 0.8,
                    roughness: 0.2 
                })
            );
            frame.castShadow = true;
            frame.receiveShadow = true;
            portalGroup.add(frame);

            const portalSurface = new THREE.Mesh(
                new THREE.PlaneGeometry(1.3, 2), // Reduced from 2, 3
                new THREE.MeshBasicMaterial({ 
                    map: portalRenderTarget.texture,
                    side: THREE.DoubleSide
                })
            );
            portalSurface.position.z = 0.06;
            portalGroup.add(portalSurface);

            const glow = new THREE.Mesh(
                new THREE.PlaneGeometry(1.4, 2.1), // Reduced from 2.1, 3.1
                new THREE.MeshBasicMaterial({ 
                    color: config.color,
                    transparent: true,
                    opacity: 0.2,
                    side: THREE.DoubleSide
                })
            );
            glow.position.z = 0.05;
            portalGroup.add(glow);

            scene.add(portalGroup);

            // ‚úÖ EXACT splat loading from working code
            let splatViewer = null;
            try {
                console.log(`   üìÑ Loading splat...`);
                
                splatViewer = new GaussianSplats3D.Viewer({
                    threeScene: portalScene,
                    renderer: renderer,
                    camera: portalCamera,
                    selfDrivenMode: false,
                    useBuiltInControls: false,
                    showLoadingSpinner: false,
                    gpuAcceleratedSort: false,
                    integerBasedSort: false,
                    sharedMemoryForWorkers: false,
                    enableSplatSorting: true,
                    halfPrecisionCovariancesOnGPU: true,
                    dynamicScene: false,
                    webXRMode: GaussianSplats3D.WebXRMode.None,
                    renderMode: GaussianSplats3D.RenderMode.Always,
                    logLevel: GaussianSplats3D.LogLevel.Info
                });

                await splatViewer.init();
                console.log(`   ‚úÖ Viewer initialized`);

                await splatViewer.addSplatScene(config.splatFile, {
                    progressiveLoad: true,
                    splatAlphaRemovalThreshold: 5,
                    position: [0, 0, 0],
                    rotation: [1, 0, 0, 0],
                    scale: [config.scale, config.scale, config.scale]
                });

                console.log(`   ‚úÖ Portal ${index} splat loaded!`);

            } catch (error) {
                console.error(`   ‚ùå Portal ${index} failed:`, error);
            }

            portals.push({
                index,
                config,
                group: portalGroup,
                scene: portalScene,
                camera: portalCamera,
                renderTarget: portalRenderTarget,
                viewer: splatViewer,
                glow
            });

            return portals[portals.length - 1];
        }

        /**
         * Update portal camera - simple parallax
         */
        function updatePortalCamera(portal) {
            const portalPos = portal.group.position;
            const cameraToPortal = new THREE.Vector3().subVectors(camera.position, portalPos);
            const strength = portal.config.parallaxStrength;

            portal.camera.position.x = -cameraToPortal.x * strength;
            portal.camera.position.y = cameraToPortal.y * strength + 1;
            portal.camera.position.z = cameraToPortal.z * strength + 5;
            portal.camera.lookAt(0, 0, 0);
        }

        // ====== PORTAL INTERACTION ======
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        renderer.domElement.addEventListener('click', (event) => {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            if (isInSplatScene) {
                // Check for hotspot clicks only in the middle portal (index 1)
                if (activePortalIndex === 1) {
                    const hotspotObjects = [];
                    hotspots.forEach(hotspot => {
                        if (hotspot.sphere.visible) {
                            hotspotObjects.push(hotspot.sphere);
                        }
                    });

                    const intersects = raycaster.intersectObjects(hotspotObjects);
                    if (intersects.length > 0) {
                        const clickedHotspot = intersects[0].object;
                        const audioIndex = clickedHotspot.userData.audioIndex;
                        console.log(`üéØ Hotspot clicked: ${clickedHotspot.userData.name}`);
                        
                        // Initialize audio context on first user interaction
                        initAudioContext();
                        playAudio(audioIndex);
                        
                        return; // Don't process other clicks
                    }
                }
            } else {
                // Portal clicking logic
                portals.forEach((portal) => {
                    const intersects = raycaster.intersectObjects(portal.group.children, true);
                    if (intersects.length > 0) {
                        enterPortal(portal.index);
                    }
                });
            }
        });

        function updatePortalProximity() {
            if (isInSplatScene) return;

            let nearPortal = false;
            portals.forEach(portal => {
                const distance = camera.position.distanceTo(portal.group.position);
                if (distance < 6) nearPortal = true;
            });

            const prompt = document.getElementById('portal-prompt');
            if (nearPortal) {
                prompt.classList.add('show');
            } else {
                prompt.classList.remove('show');
            }
        }

        function enterPortal(portalIndex) {
            console.log(`üö™ Entering portal ${portalIndex}`);
            isInSplatScene = true;
            activePortalIndex = portalIndex;

            controls.enabled = false;
            splatControls.enabled = true;

            // ‚úÖ CRITICAL: Switch viewer to use main camera
            const activePortal = portals[portalIndex];
            if (activePortal && activePortal.viewer) {
                activePortal.viewer.camera = camera;
                console.log('‚úÖ Switched viewer to main camera');
            }

            camera.position.set(0, 2, 8);
            camera.lookAt(0, 0, 0);
            splatControls.target.set(0, 0, 0);
            splatControls.update();

            scene.background = new THREE.Color(0x1a1a2a);

            floor.visible = false;
            backWall.visible = false;
            leftWall.visible = false;
            rightWall.visible = false;
            cube.visible = false;
            portals.forEach(p => p.group.visible = false);
            spotlight1.visible = false;
            spotlight2.visible = false;
            spotlight3.visible = false;

            // Show hotspots only in the middle portal (index 1)
            if (portalIndex === 1) {
                console.log('üéØ Showing hotspots for middle portal');
                hotspots.forEach((hotspot, index) => {
                    hotspot.sphere.visible = true;
                    hotspot.glow.visible = true;
                    
                    // CRITICAL FIX: Add hotspots to the portal scene so they render with the splat
                    if (activePortal && activePortal.scene) {
                        activePortal.scene.add(hotspot.sphere);
                        activePortal.scene.add(hotspot.glow);
                    }
                    
                    console.log(`   Hotspot ${index + 1} made visible at:`, hotspot.sphere.position);
                    console.log(`   Hotspot ${index + 1} opacity:`, hotspot.sphere.material.opacity);
                });
                document.getElementById('hotspot-info').classList.add('show');
                document.getElementById('hotspot-controls').classList.add('show'); // Show control panel
                console.log('‚úÖ Hotspots and controls should now be visible!');
            } else {
                console.log('‚ö™ Not middle portal, hiding hotspots');
                hotspots.forEach(hotspot => {
                    hotspot.sphere.visible = false;
                    hotspot.glow.visible = false;
                    
                    // Remove from any portal scene
                    if (hotspot.sphere.parent && hotspot.sphere.parent !== scene) {
                        hotspot.sphere.parent.remove(hotspot.sphere);
                    }
                    if (hotspot.glow.parent && hotspot.glow.parent !== scene) {
                        hotspot.glow.parent.remove(hotspot.glow);
                    }
                });
                document.getElementById('hotspot-info').classList.remove('show');
                document.getElementById('hotspot-controls').classList.remove('show'); // Hide control panel
            }

            let instructionText = `
                <h2>üåÄ Inside ${portals[portalIndex].config.name}</h2>
                <ul>
                    <li>Drag to rotate view</li>
                    <li>Scroll to zoom in/out</li>
                    <li>Explore the 3D space</li>`;
            
            if (portalIndex === 1) {
                instructionText += `<li>üéØ Look for glowing spheres to click!</li>`;
                instructionText += `<li>üîä Click to play/stop audio</li>`;
            }
            
            instructionText += `<li>Press ESC to exit</li>
                </ul>
            `;

            document.getElementById('instructions').innerHTML = instructionText;
            document.getElementById('portal-prompt').classList.remove('show');
        }

        function exitPortal() {
            console.log('üö™ Exiting portal...');
            
            // ‚úÖ CRITICAL: Restore portal camera
            const activePortal = portals[activePortalIndex];
            if (activePortal && activePortal.viewer) {
                activePortal.viewer.camera = activePortal.camera;
                console.log('‚úÖ Restored portal camera');
            }

            // Clean up hotspots from portal scene
            if (activePortalIndex === 1 && activePortal && activePortal.scene) {
                // Stop any playing audio when exiting
                for (let i = 0; i < currentlyPlayingAudio.length; i++) {
                    if (currentlyPlayingAudio[i]) {
                        try {
                            currentlyPlayingAudio[i].stop();
                        } catch (e) {
                            console.warn('Error stopping audio on exit:', e);
                        }
                        currentlyPlayingAudio[i] = null;
                        currentlyPlayingType[i] = null;
                    }
                }
                
                hotspots.forEach(hotspot => {
                    activePortal.scene.remove(hotspot.sphere);
                    activePortal.scene.remove(hotspot.glow);
                    // Add back to main scene but keep invisible
                    scene.add(hotspot.sphere);
                    scene.add(hotspot.glow);
                    hotspot.sphere.visible = false;
                    hotspot.glow.visible = false;
                });
                console.log('üéØ Hotspots and audio cleaned up from portal scene');
            }

            isInSplatScene = false;
            activePortalIndex = -1;

            controls.enabled = true;
            splatControls.enabled = false;

            camera.position.set(0, 1.6, 8);
            controls.target.set(0, 0.8, -3); // Updated to match new lower portal height
            controls.update();

            scene.background = new THREE.Color(0x0a0a0a);

            floor.visible = true;
            backWall.visible = true;
            leftWall.visible = true;
            rightWall.visible = true;
            cube.visible = true;
            portals.forEach(p => p.group.visible = true);
            spotlight1.visible = true;
            spotlight2.visible = true;
            spotlight3.visible = true;

            document.getElementById('hotspot-info').classList.remove('show');
            document.getElementById('hotspot-controls').classList.remove('show'); // Hide control panel

            document.getElementById('instructions').innerHTML = `
                <h2>üåÄ Gallery Controls</h2>
                <ul>
                    <li>Left click + drag to orbit</li>
                    <li>Scroll to zoom in/out</li>
                    <li>Click any portal to enter</li>
                    <li>Each portal shows different view</li>
                </ul>
            `;
        }

        window.addEventListener('keydown', (event) => {
            if (event.key === 'Escape' && isInSplatScene) {
                exitPortal();
            }
        });

        // ====== ANIMATION LOOP ======
        function animate() {
            requestAnimationFrame(animate);

            if (isInSplatScene) {
                // Inside portal: render splat scene with main camera
                splatControls.update();

                const activePortal = portals[activePortalIndex];
                if (activePortal && activePortal.viewer) {
                    activePortal.viewer.update();
                    
                    // ‚úÖ CRITICAL: Must call viewer.render() for splat to show
                    renderer.setRenderTarget(null);
                    activePortal.viewer.render();  // This renders the splat!
                }

                // Animate hotspots if visible
                if (activePortalIndex === 1) {
                    const time = Date.now() * 0.002;
                    hotspots.forEach((hotspot, index) => {
                        if (hotspot.sphere.visible && hotspot.sphere.parent === activePortal.scene) {
                            // Pulsing effect
                            hotspot.sphere.material.opacity = 0.7 + Math.sin(time * 3 + index * 2) * 0.3;
                            hotspot.glow.material.opacity = 0.4 + Math.sin(time * 2 + index * 2) * 0.2;
                            
                            // Gentle floating - use current position from sliders as base
                            const baseY = hotspotPositions[index].y;
                            const floatOffset = Math.sin(time * 1.5 + index * 3) * 0.2;
                            hotspot.sphere.position.y = baseY + floatOffset;
                            hotspot.glow.position.copy(hotspot.sphere.position);
                        }
                    });
                }
            } else {
                // Outside: render gallery with portal previews
                controls.update();
                updatePortalProximity();

                cube.rotation.x += 0.005;
                cube.rotation.y += 0.005;

                // Render each portal to its texture
                portals.forEach(portal => {
                    updatePortalCamera(portal);

                    if (portal.viewer) {
                        portal.viewer.update();
                        
                        // ‚úÖ CRITICAL: Render splat to portal texture
                        renderer.setRenderTarget(portal.renderTarget);
                        portal.viewer.render();  // This renders the splat to texture!
                        renderer.setRenderTarget(null);
                    }

                    const time = Date.now() * 0.001;
                    portal.glow.material.opacity = 0.2 + Math.sin(time * 2 + portal.index) * 0.1;
                });

                // Render main gallery scene
                renderer.render(scene, camera);
            }
        }

        // ====== INITIALIZATION ======
        async function init() {
            document.getElementById('loading-text').textContent = 'two secs, just creating portal gallery...';

            // Create hotspots first
            createHotspots();

            for (let i = 0; i < PORTAL_CONFIGS.length; i++) {
                document.getElementById('loading-text').textContent = `Loading portal ${i + 1}/${PORTAL_CONFIGS.length}...`;
                await createPortal(PORTAL_CONFIGS[i], i);
            }

            document.getElementById('portal-count').textContent = portals.length;
            document.getElementById('loading').style.display = 'none';
            document.getElementById('instructions').style.display = 'block';
            document.getElementById('gallery-info').style.display = 'block';
            document.getElementById('file-info').style.display = 'block';

            animate();
            console.log('‚úÖ Portal gallery with hotspots ready!');
        }

        // ====== WINDOW RESIZE ======
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // ====== START ======
        init().catch(err => {
            console.error('Init failed:', err);
            document.getElementById('loading-text').textContent = 'Error: ' + err.message;
        });
    </script>
</body>
</html>